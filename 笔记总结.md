# 第一天git

## 常见的版本控制工具

主流的版本控制器有如下这些：    

Git（重要） 

SVN（Subversion）（重要）

CVS（Concurrent Versions System）

VSS（Micorosoft Visual SourceSafe）

TFS（Team Foundation Server） 

Visual Studio Online

## 集中版本控制svn

所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改,集中式版本控制，需要联网才行

缺点: 1. 所有的历史代码都存放在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回

优点: 1. 个人本地占用储存空间较小,只需要保存自己修改的内容即可

分布式版本控制 Git

每个人都拥有全部的代码，可以在本地提交，联网之后push到远程仓库就行，只要有一个用户数据没问题，就可以恢复所有数据。

优点：不会因为服务器损坏或者网络问题，造成不能工作的情况！

缺点：增加了本地存储空间的占用

## 启动git

Git Bash ：Unix与Linux风格的命令行，使用最多，推荐最多

Git CMD：Windows风格的命令行

Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

Git区域

Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。

## 常用的Linux命令

平时一定要多使用这些基础的命令！

1）cd : 进入目录。

2）cd . . 回退到上一个目录，直接cd进入默认目录

3）pwd : 显示当前所在的目录路径。

4）ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）

5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。

6）rm: 删除一个文件, rm index.js 就会把index.js文件删除。

7）mkdir: 新建一个目录,就是新建一个文件夹。

8）rm -r : 删除一个文件夹, rm -r src 删除src目录

9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。

10）reset 重新初始化终端/清屏。

11）clear 清屏。

12）history 查看命令历史。

13）help 帮助。（Mac除外）

14）exit 退出。

15）#表示注释

16) ls: 查看桌面的所有文件

## Git文件四种状态

Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.

Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件

Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !

Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified

## 本地仓库搭建

1、创建全新的仓库，需要用GIT管理的项目的根目录执行：

\# 在当前目录新建一个Git代码库$ git init

2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。

1:windows查看隐藏文件夹 在查看里面勾选

2:mac查看隐藏文件夹 

## 克隆远程仓库

1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！

\# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]

# 第二天es6

## JS数据类型

1. ***基本数据类型***

number、string、undefined、null、boolean、symbol、bigint

2. ***引用数据类型【对象类型】***

(1) 标准普通对象: object

(2) 标准特殊对象： Array、RegExp、Date、Math、Error...

(3) 非标准特殊对象：Number、String、Boolean...

(4) 可调用对象/执行对象：function

##  JS数据类型转换

#  -------1.Number

Js中的数据类型转换有两种模式，**一种是隐式转换，一种是显示转换**。

<u>**隐式转换**</u>：*浏览器默认去转换，用**Number()***

**①Number**
转换规则：
1.字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN

2.布尔值转换为数字:true–>1,false–>0

3.null–>0,undefined–>NaN

4.Symbol无法转换为数字，会报错:Uncaught TypeError: Cannot convert a Symbol value to a number

 5.BigInt去除"n"

6.把对象转换为数字

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串
- 最后再把字符串基于Number方法转换为数字

 ②**parseInt与parseFloat**

parseInt(val,radix)接受两个参数

- 第一个参数val必须是字符串，如果不是，要先隐式转换为字符串，调用String()
- 第二个参数radix表示进制，如果不写，或者写0，则默认是10进制

#### 2.String

**情景1：String(val)或者val.toString()**
***转换规则：除对象以外，都是直接用字符串包起来**

对象转字符串的转换规则，与对象转数字的规则一样：

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串

**情景2：加号+**
***除了数学运算，还可能代表字符串拼接，也会发生字符串转换***

**（1）+有两边，一边是字符串或者某些对象**

console.log(10+'10');	//'1010'

按对象转字符串的转换规则
先new Date()[Symbol.toPrimitive] (‘default’)—>‘Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)’
得到字符串，然后拼接上10—>‘10Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)

- 先[10] [Symbol.toPrimitive]—>undefined
- 然后[10].valueOf()—>[10]

- 再然后[10].toString()—>‘10’

- 最后10+'10’字符串拼接—>‘1010’

#### 3.Boolean

**转换规则：**
***除了“0/NaN/空字符串/null/undefined"五个值是false，其余值都是true***
情景：

- Boolean(val)
- !/!! （！表示取反，！！表示取反再取反，所以！！跟Boolean()是一个意思）
- 条件判断

4.比较时的相互转换规则

**情景1：对象==字符串**
***按对象转字符串规则Symbol.toPrimitive—>valueOf—>toString***
***将对象转成字符串，然后比较***

**情景2：null==undefined**

​	console.log(null==undefined);//true

console.log(null===undefined);//false

**情景3：对象==对象**
***比较的是堆内存地址，地址相同则相等***

**情景4：NaN**

console.log(NaN==NaN);//false
	console.log(NaN===NaN);//false

NaN与任何值都不相等,包括NaN本身

情景5：***除了以上情景，只要两边类型不一致，剩下的都是转换数字，然后再进行比较***
***"==="绝对相等,如果两边类型不同，则直接是false，不会发生数据类型转换。***
例1：console.log([]==false);	//true

# 检测数据类型

### **1.typeof**

***typeof 返回对应类型的字符串***

***总结：typeof 检测基本数据类型比较准，null检测为object不代表它是引用数据类型，null为空是特殊的基本数据类型，引用数据类型都为 object，内置构造函数和函数都为 function***

### 2.instanceof

 ***instanceof 检测类型返回布尔值***

***总结：instanceof 不能检测基本数据类型，判断前者的 proto 是否在后者的原型对象上***

### 3.constructor

***constructor 返回构造函数***

***总结：返回当前值的构造函数，比如向 [] 数组这种，都是通过 new Array() 这样去创建实例的，这个 Array 就是数组的构造函数***

### 4.Object.prototype.toString.call()

***总结：这个方法查的特别的准，可以检查任意类型***

### 5.Object.getPrototypeOf()

// 获取原型，和想要的原型做对比
console.log(Object.getPrototypeOf([]) === Array.prototype); // true
console.log(Object.getPrototypeOf({}) === Object.prototype); // true

### 五种方法的总结**

- ***typeof：这种方法只能检测基本数据类型，null 和对象的不准***

- ***instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型***

- ***constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷***

- ***Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测***

- ***Object.getPrototypeOf()：这种方法获取原型***

  # 作用域及作用域链

  - 所谓作用域通俗点讲就是变量的可作用范围。
  - 一般有三种作用域。全局，函数，块。

## 变量提升及函数提升

##### 什么是变量提升？

变量提升是指将变量声明提升到它所在的作用域的最开始部分

## 什么是函数提升

 创建函数有两种形式，一种是函数声明，另外一种是函数字面量，**只有函数声明才有变量提升**

## 函数提升与变量提升的优先级

**由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。**

# 运算符

### 1.数学运算符

数学运算符就是常见的**加(+)、减(-)、乘(*)、除(/)、等于(=)、求幂(**)、**自增(++)、自减(--)、加等于(+=)、减等于(-=)**等

### 2.比较运算符

与数学运算中的比较相同**：大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)**等；注意: **全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样**；

### 3.三元表达式

三元表达式可以替代简单的if条件，**表达式为判断条件 ？条件为真 ：条件为假**。

if（3 > 4）{
    console.log("条件为真");
}else {
    console.log("条件为假");
}
// 三元表达式 —— 代码更加简洁清晰
3 > 4 ? console.log("条件为真") : console.log("条件为假")

### 4.短路运算符 && 与 ||

**短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了。**

- &&：从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值；

- || ：为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值；

  // 1.利用||设置默认值，防止代码出错。

  // 假设data需要取出后台返回的context数组,但返回中不包含context，便可以使用||防止找不到对应值而报错。

  const data = res.context || [];
  // 2.利用&&来省略简单if判断,例如：当某一条件为真时执行函数
  if(1 < 2) {
      fn()
  }
  // 可以简写为
  (1 < 2) && fn()

# day3 JS部分

## 数组方法

### isArray() ，判断是不是一个数组

let arr = [1,2];
console.log(arr.isArray()); //true

### push()，向数组***末尾添加***一个或者多个元素，

### ***返回新数组到长度**。**会改变原数组***

let arr = [1,2];
let returnValue = arr.push(3,4,5);
console.log(arr); // [1,2,3,4,5]
console.log(returnValue) // 5

### pop()，删除并返回数组的最后一个元素***，若该数组为空，***

### ***则返回undefined。***原数组改变。***

```
let arr = [1,2,3];
let del = arr.pop();
console.log(arr); // [1,2]
console.log(del); // 3
```

### unshift()*向数组的开头添加一个或多个元素，并返回新的数组长度。原数组改变***

```
let arr = [1,2,3];
let returnValue = arr.unshift(4,5);
console.log(arr); // [4,5,1,2,3]
console.log(returnValue) // 5
```

### shift()**删除并返回数组的第一个元素，若该数组为空，则返回undefined。原数组改变。*

```
let arr = [1,2,3];
let del = arr.shift();
console.log(del);//1
```

### concat()**合并两个或多个数组，生成一个新的数组。原数组不变***

```
let arr = [1,2];
let b = [3,4];
let result = arr.concat(b);
console.log(result) // [1,2,3,4];
```

### reverse()**将数组倒序。原数组改变**

```
let arr = [1,2,3,4];
arr.reverse();
console.log(a); // [4,3,2,1]
```

### sort()对数组元素进行排序，根据字符串UniCode码排序，原数组改变



```
let arr = [1,2,4,3];
// 升序
arr.sort((a,b)=>{
    return a - b;
});
// 降序
arr.sort((a,b)=>{
    return b - a;
})
```

**原理**

1. **当返回值为负数时，那么前面的数在前面，也就是不动**
2. **当返回值为正数时，那么后面的数在前**
3. **为0，不动**

### join()

***将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。***

```
let arr = [1,2,3,4];
let str = arr.join();
let str1 = arr.join('-');
console.log(str); // 1,2,3,4
console.log(str1); // 1-2-3-4
```

### toString()

***此方法将数组转化为字符串***

```
let arr = [1, 2, 3, 4, 5];
let str = arr.toString()
console.log(str)// 1,2,3,4,5
```

### slice()**slice(start,end).从start开始，end之前结束，不到end。不改变原数组**

```
let a = ['项目一','项目二','项目三']
let arr = arr.slice(0,2);
console.log(a); // ["项目一","项目二","项目三"]
console.log(arr); // ["项目一","项目二"]
```

### splice()***splice(start, number, item, item) 从start开始删除number位，***

### ***然后将后面参数插入数组。返回删除元素组成对数组，会改变原数组***

```
let arr = [1,2,3];
let result = arr.slice(1,0,33);
console.log(arr); // [1,2,33,3]
console.log(result); // []
 
```

### indexOf()，**来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.indexOf('项目二');
console.log(arr); // 1
```

### includes()**判断是否包含某一元素,直接返回true或者false表示是否包含元素，对NaN一样有效。**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.includes('项目一');
console.log(result) // true
```

## 循环方法

### map

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- 不改变原数组
- ***返回值是一个新的数组***

```
let testArr = ['子项0','子项1','子项2'];
let resultArr = testArr.map((item, index) => {
  return `处理·${item}`
});
console.log(resultArr);
// 结果： ["处理·子项0", "处理·子项1", "处理·子项2"]
```

### forEach

- 对数组的每个元素执行一次提供的函数。
- ***总是返回undefined。***
- 不改变原数组

```
let testArr = ['子项0','子项1','子项2'];
testArr.forEach((item, index)=>{
  return `forEach处理${item}`
});
```

### filter

- 对数组的每一项都进行***过滤***，返回符合条件的item组成的数组
- ***不会改变原数组***

```
let filterArr = ['子项0','子项1','子项2'];
let filterResult = filterArr.filter((item, index) => {
  return item === '子项0';
});
console.log(filterArr); // ["子项0", "子项1", "子项2"]
console.log(filterResult);  ["子项0"]
```

### find

- 遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined
- 不会改变数组

```
let findArr = ['子项0','子项1','子项2']
let findResult = findArr.find((item, index) => {
  return item === '子项0';
});
console.log(findResult);
// 结果为: 子项0
```

### findIndex

- ***遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。***
- ***不会改变数组对象。***

```
let findIndexArr = ['子项0','子项1','子项2'];
let findIndexResult = findIndexArr.findIndex((item, index)=>{
  return item === '子项0';
});
console.log(findIndexResult);
// 结果为： 0
```

### every

- 对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。***简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false***

```
let everyArr = [2,3,4];
let everyResult = everyArr.every((item, index)=>{
  return item > 0
});
console.log(everyResult);
// 结果为: true
```

### some

是对数组中每一项运行指定函数，如果该函数对***任一项返回true，则返回true。***

```
let someArr = [2,3,4];
let someResult = someArr.some((item, index)=>{
  return item > 3
});
console.log(someResult);
// 结果为: true
```

### reduce

- 接收一个函数作为累加器（accumulator），数组中的每个值***（从左到右）***开始缩减，最终为一个值。
- 第二个参数作为第一次调用的a的值

```
// reducer
let reduceArr = [0,1,2,3,4]
let reduceResult = reduceArr.reduce((a, b)=>{
  return a + b;
});
console.log(reduceResult);
// 结果: 10
```

### reduceRight

- 和reduce一样是累加器，不过是***从右往左计算***
- 第二个参数作为第一次调用的a的值



## 闭包

答：闭包说的通俗⼀点就是打通了⼀条在函数外部访问函数内部作⽤域的通道。正常情况下函数外部是
访问不到函数内部作⽤域变量的，
表象判断是不是闭包:函数嵌套函数,内部函数被 return 内部函数调⽤外层函数的局部变量
优点：可以隔离作⽤域，不造成全局污染
缺点：由于闭包⻓期驻留内存，则⻓期这样会导致内存泄露
如何解决内存泄露：将暴露全外部的闭包变量置为 null
适⽤场景：封装组件，for 循环和定时器结合使⽤,for 循环和 dom 事件结合.可以在性能优化的过程中,节流
防抖函数的使⽤,导航栏获取下标的使⽤。

## 原型和原型链

原型 显式原型 prototype
构造函数都有显式原型 上面放的是能够被所有实例化对象所使用的属性和方法

隐式原型 \*\* ———proto--
每一个实例都有隐式原型 指向构造函数的显式原型

constructor
本身是构造函数的意思 每一个显式原型上都有一个构造函数指向 构造函数本身

原型链
一个对象 如果自己的构造函数里有这个方法就用自己的 如果没有 就用它继承的，一层一层找，最终会找到 object。

## this的理解和指向

在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
如果没有调用者，就指向全局对象 window。

1. 构造函数
   构造函数里的 this 指向实例化对象
2. 箭头函数
   箭头函数里没有 this，用的 this 是上层所在环境的 this
3. 函数是对象的属性
   this 指向这个对象
4. dom 节点调用一个事件 就指向这个 dom
5. 全局调用 就指向 widnow
6. 计时器里的 this 永远指向 window

## 多维变一维

#####  利用循环每个元素把得到的元素push新数组

  let a=[[4,5],[6,7]]

  let b=[]

  a.forEach(item=>{

​    item.forEach(val=>{

​      b.push(val)

​    })

  })

  console.log(b);

  // 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维数组。

#####  该方法返回一个新数组，对原数据没有影响。

  let data=[1,2,3,[4,5],11,22,[88,99]]

  let res=data.flat(2)

  console.log(res);

# 浅拷贝和深拷贝

浅拷贝 只拷贝一层 如果是复杂数据类型 就复制地址
深拷贝 不管这个对象有多少层 都会拷贝到值而不是地址

常见的浅复制有哪些：展开运算符 concat Object.assign
let arr2 = [...arr];
let arr2 = arr.concat();
let arr2 = Object.assign({}, arr);

深拷贝

JSON.parse(JSON.stringify())

递归 

实现 
先定义一个函数作为递归函数，然后定义一个空对象保存复制之后的结果，用for in 循环这个对象，然后进行判断如果是基本数据类型就直接复制，如果是对象就再执行这个递归函数

# JS 常见的几种继承方式以及优缺点。

1.原型链继承
-  优点：最简单的方式，将子类的原型指向父类的实例即可。
-  缺点：一是引用类型的属性被所有实例共享，修改堆内存数据时会将所有实例数据都修改，但是直接创建新的存储对象就不会产生这个错误。二是创建子类实例时不能向超类型的构造函数中传递参数。（因此开发中很少单独使用原型链）

2.借用构造函数（类式继承）
-   优点：能实现属性的继承，也可以在子类型创建实例时为父类型传递参数。
-   缺点：借用构造函数虽然解决了刚才的问题，但不能继承构造函数的原型，只能继承构造函数的属性和方法。因此每次创建子类实例时都会调用构造函数、复制构造函数，会影响性能。
-   所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承。

3.组合式继承
-   优点：组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性，结合了原型链继承和借用构造函数的优点。
。  缺点：如果再添加一个子类型给这个子类型原型上单独添加一个方法那么其他子类型也同时拥有这个方法，因为他们都指向同一个父类型原型。

4.原型式继承
        原型式继承的的实现方法与普通继承的实现方法不同，原型式继承并没有使用严格意义上的构造函数，而是借
助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。

-   优点：没有创建自定义类型，因为只是套了个壳子返回对象，这个函数顺理成章就成了创建的新对象。
- 　缺点：没用到原型，无法复用。

5.寄生继承
-   优缺点：跟构造函数继承类似，调用一次函数就得创建一遍方法，无法实现函数复用，效率较低

6.寄生组合式继承

-   结合组合继承优点、寄生继承的优点，目前JS继承中使用的都是这个继承方法。组合继承的缺点是两次调用父级构造函数，一次是在创建子级原型时一个是在子级构造函数内部，而这个缺点我们可以用寄生继承的特性来优化，减少一次调用父级构造函数，也就是继承父级构造函数的原型来创建子级原型。

# 同步异步 宏任务 微任务 事件循环***

在 js 中 任务的执行模式有两种 同步（log，for 循环等等） 和 异步（ajax 请求 计时器等）
在异步任务中 又将任务分成了宏任务和微任务，宏任务（计时器，ajax 请求）是浏览器发起的 微任务（promise.then）是 js 自身发起的 在异步任务中 微任务先执行 宏任务后执行

所以任务的执行顺序是：

同步先执行-》异步里的微任务-》异步里的宏任务

promise 本身是一个同步 then 是一个异步的微任务

事件循环 event loop

1. 整个 script 标签是一个宏任务 最开始的时候 会执行整体代码
2. 进行同步任务和异步任务的区分
3. 同步任务直接执行 异步任务进行微任务和宏任务的划分
4. 同步执行完了 执行微任务队列里的微任务 完成后再执行宏任务队列里的宏任务
5. 直到执行完成就进行下一次轮回

# day4

## 获取DOM获取节点

1. 通过ID获取节点 【返回具体某个节点】
document.getElementById(ID名)
2. 通过标签名获取节点 【返回节点数组，即使只有一个】
  document.getElementsByTagName(标签名)
3. 3.通过标签的name值获取节点 【返回节点数组】
  document.getElementsByName(Name名)
4. 通过class值来获取节点 【返回节点数组】
  document.getElementsByClassName(Class名)
5. 根据选择器返回找到结果集中的第一个
  document.querySelect(“选择器”)
6. 根据选择器返回找到的结果集，是个节点数组
  document.querySelectAll(“选择器”)

## 数组和伪数组的区别

- 伪数组的定义

  - 拥有`length`属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)

  - 不具有数组所具有的方法

    所谓真数组，其实可以直接称为：数组。
    当一个对象具有以下特点时，可以称为数组：

    可以按照索引的方式，存储多个数组
    具有length属性，表示数组内数据的长度（个数）
    对象的原型属性__proto__，指向Array类，且可以使用Array的原型对象prototype身上的属性和方法，如：push，pop等。如图1：

常见的伪数组有：函数参数arguments，DOM对象列表(例如document.querySelectorAll('div'))，jQuery中的$('div')等
Array.prototype
伪数组没有Array.prototype，它只是一个对象
数组有Array.prototype，他是对象的同时，也是数组
索引（index）和长度（length）
伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
数组的索引和长度是内置属性定义：

## 将伪数组转成真数组

**方法1:遍历：创建一个空数组，循环遍历伪数组，将遍历出的数据逐一放在空数组中**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [];           // 先创建空数组
for(var i=0;i<ali.length;i++){  // 循环遍历伪数组
    arr[i] = ali[i];    // 取出伪数组的数据，逐个放在真数组中
}

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法2:使用slice方法：利用Array原型对象的slice方法，配合apply，将slice中的this指向伪数组**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.prototype.slice.apply(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法3:利用ES6提供的Array的from方法**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.from(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法4:利用ES6提供的展开运算符（…）**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [...ali];

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法5:利用原型的复制：将伪数组的__proto__复制为Array的prototype。但是这种方法有局限性**

## arguments

###### **arguments是一个类似于数组的对象，对应于传递给函数的参数**，他有length属性，arguments[ i ]来访问对象中的元素，但是它不能用[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)的一些方法。例如push、pop、slice等。

arguments虽然不是一个数组，但是它可以转成一个真正的数组。

function argText(a,b,c){
    var actual = arguments.length;   //实际传参个数
    var hope = argText.length   //期望传参个数
    console.log(actual,hope);
    //转换数组：
    var args = [].slice.call(arguments);   //第一种
    var args = Array.prototype.slice.call(arguments);   //第二种
    let args = Array.from(arguments);   //第三种
    let args = [...arguments];   //第四种
    console.log(args)
}
argText(1,2)
//输出: 2 3   

每一个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式" [ ] "引用arguments的元素。

arguments.length为函数实参个数，arguments.callee引用函数自身。

arguments对象是所有函数中可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此参数包含传递给函数的每个参数条目。

arguments.callee：Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。

function argText(){  

  var e = arguments.callee.toString();    console.log(e); } 

argText(); 

##### **6.arguments.caller：指向调用当前函数的函数**

function argText(){
    if(argText.caller){
        var caller = argText.caller.toString();
        console.log(caller);
    }else{
        console.log("no caller");
    }  
}
function handler(){
    argText();
}
function copyHandler(){
    handler();
}
argText()
//输出: no caller
handler()
//输出: function handler(){argText();}
copyHandler();     
//输出: function handler(){argText();}   