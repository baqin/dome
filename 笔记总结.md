# 第一天git

## 常见的版本控制工具

主流的版本控制器有如下这些：    

Git（重要） 

SVN（Subversion）（重要）

CVS（Concurrent Versions System）

VSS（Micorosoft Visual SourceSafe）

TFS（Team Foundation Server） 

Visual Studio Online

## 集中版本控制svn

所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改,集中式版本控制，需要联网才行

缺点: 1. 所有的历史代码都存放在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回

优点: 1. 个人本地占用储存空间较小,只需要保存自己修改的内容即可

分布式版本控制 Git

每个人都拥有全部的代码，可以在本地提交，联网之后push到远程仓库就行，只要有一个用户数据没问题，就可以恢复所有数据。

优点：不会因为服务器损坏或者网络问题，造成不能工作的情况！

缺点：增加了本地存储空间的占用

## 启动git

Git Bash ：Unix与Linux风格的命令行，使用最多，推荐最多

Git CMD：Windows风格的命令行

Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

Git区域

Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。

## 常用的Linux命令

平时一定要多使用这些基础的命令！

1）cd : 进入目录。

2）cd . . 回退到上一个目录，直接cd进入默认目录

3）pwd : 显示当前所在的目录路径。

4）ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）

5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。

6）rm: 删除一个文件, rm index.js 就会把index.js文件删除。

7）mkdir: 新建一个目录,就是新建一个文件夹。

8）rm -r : 删除一个文件夹, rm -r src 删除src目录

9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。

10）reset 重新初始化终端/清屏。

11）clear 清屏。

12）history 查看命令历史。

13）help 帮助。（Mac除外）

14）exit 退出。

15）#表示注释

16) ls: 查看桌面的所有文件

## Git文件四种状态

Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.

Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件

Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !

Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified

## 本地仓库搭建

1、创建全新的仓库，需要用GIT管理的项目的根目录执行：

\# 在当前目录新建一个Git代码库$ git init

2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。

1:windows查看隐藏文件夹 在查看里面勾选

2:mac查看隐藏文件夹 

## 克隆远程仓库

1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！

\# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]

# 第二天es6

## JS数据类型

1. ***基本数据类型***

number、string、undefined、null、boolean、symbol、bigint

2. ***引用数据类型【对象类型】***

(1) 标准普通对象: object

(2) 标准特殊对象： Array、RegExp、Date、Math、Error...

(3) 非标准特殊对象：Number、String、Boolean...

(4) 可调用对象/执行对象：function

##  JS数据类型转换

#  -------1.Number

Js中的数据类型转换有两种模式，**一种是隐式转换，一种是显示转换**。

<u>**隐式转换**</u>：*浏览器默认去转换，用**Number()***

**①Number**
转换规则：
1.字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN

2.布尔值转换为数字:true–>1,false–>0

3.null–>0,undefined–>NaN

4.Symbol无法转换为数字，会报错:Uncaught TypeError: Cannot convert a Symbol value to a number

 5.BigInt去除"n"

6.把对象转换为数字

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串
- 最后再把字符串基于Number方法转换为数字

 ②**parseInt与parseFloat**

parseInt(val,radix)接受两个参数

- 第一个参数val必须是字符串，如果不是，要先隐式转换为字符串，调用String()
- 第二个参数radix表示进制，如果不写，或者写0，则默认是10进制

#### 2.String

**情景1：String(val)或者val.toString()**
***转换规则：除对象以外，都是直接用字符串包起来**

对象转字符串的转换规则，与对象转数字的规则一样：

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串

**情景2：加号+**
***除了数学运算，还可能代表字符串拼接，也会发生字符串转换***

**（1）+有两边，一边是字符串或者某些对象**

console.log(10+'10');	//'1010'

按对象转字符串的转换规则
先new Date()[Symbol.toPrimitive] (‘default’)—>‘Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)’
得到字符串，然后拼接上10—>‘10Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)

- 先[10] [Symbol.toPrimitive]—>undefined
- 然后[10].valueOf()—>[10]

- 再然后[10].toString()—>‘10’

- 最后10+'10’字符串拼接—>‘1010’

#### 3.Boolean

**转换规则：**
***除了“0/NaN/空字符串/null/undefined"五个值是false，其余值都是true***
情景：

- Boolean(val)
- !/!! （！表示取反，！！表示取反再取反，所以！！跟Boolean()是一个意思）
- 条件判断

4.比较时的相互转换规则

**情景1：对象==字符串**
***按对象转字符串规则Symbol.toPrimitive—>valueOf—>toString***
***将对象转成字符串，然后比较***

**情景2：null==undefined**

​	console.log(null==undefined);//true

console.log(null===undefined);//false

**情景3：对象==对象**
***比较的是堆内存地址，地址相同则相等***

**情景4：NaN**

console.log(NaN==NaN);//false
	console.log(NaN===NaN);//false

NaN与任何值都不相等,包括NaN本身

情景5：***除了以上情景，只要两边类型不一致，剩下的都是转换数字，然后再进行比较***
***"==="绝对相等,如果两边类型不同，则直接是false，不会发生数据类型转换。***
例1：console.log([]==false);	//true

# 检测数据类型

### **1.typeof**

***typeof 返回对应类型的字符串***

***总结：typeof 检测基本数据类型比较准，null检测为object不代表它是引用数据类型，null为空是特殊的基本数据类型，引用数据类型都为 object，内置构造函数和函数都为 function***

### 2.instanceof

 ***instanceof 检测类型返回布尔值***

***总结：instanceof 不能检测基本数据类型，判断前者的 proto 是否在后者的原型对象上***

### 3.constructor

***constructor 返回构造函数***

***总结：返回当前值的构造函数，比如向 [] 数组这种，都是通过 new Array() 这样去创建实例的，这个 Array 就是数组的构造函数***

### 4.Object.prototype.toString.call()

***总结：这个方法查的特别的准，可以检查任意类型***

### 5.Object.getPrototypeOf()

// 获取原型，和想要的原型做对比
console.log(Object.getPrototypeOf([]) === Array.prototype); // true
console.log(Object.getPrototypeOf({}) === Object.prototype); // true

### 五种方法的总结**

- ***typeof：这种方法只能检测基本数据类型，null 和对象的不准***

- ***instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型***

- ***constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷***

- ***Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测***

- ***Object.getPrototypeOf()：这种方法获取原型***

  # 作用域及作用域链

  - 所谓作用域通俗点讲就是变量的可作用范围。
  - 一般有三种作用域。全局，函数，块。

## 变量提升及函数提升

##### 什么是变量提升？

变量提升是指将变量声明提升到它所在的作用域的最开始部分

## 什么是函数提升

 创建函数有两种形式，一种是函数声明，另外一种是函数字面量，**只有函数声明才有变量提升**

## 函数提升与变量提升的优先级

**由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。**

# 运算符

### 1.数学运算符

数学运算符就是常见的**加(+)、减(-)、乘(*)、除(/)、等于(=)、求幂(**)、**自增(++)、自减(--)、加等于(+=)、减等于(-=)**等

### 2.比较运算符

与数学运算中的比较相同**：大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)**等；注意: **全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样**；

### 3.三元表达式

三元表达式可以替代简单的if条件，**表达式为判断条件 ？条件为真 ：条件为假**。

if（3 > 4）{
    console.log("条件为真");
}else {
    console.log("条件为假");
}
// 三元表达式 —— 代码更加简洁清晰
3 > 4 ? console.log("条件为真") : console.log("条件为假")

### 4.短路运算符 && 与 ||

**短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了。**

- &&：从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值；

- || ：为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值；

  // 1.利用||设置默认值，防止代码出错。

  // 假设data需要取出后台返回的context数组,但返回中不包含context，便可以使用||防止找不到对应值而报错。

  const data = res.context || [];
  // 2.利用&&来省略简单if判断,例如：当某一条件为真时执行函数
  if(1 < 2) {
      fn()
  }
  // 可以简写为
  (1 < 2) && fn()

# day3 JS部分

## 数组方法

### isArray() ，判断是不是一个数组

let arr = [1,2];
console.log(arr.isArray()); //true

### push()，向数组***末尾添加***一个或者多个元素，

### ***返回新数组到长度**。**会改变原数组***

let arr = [1,2];
let returnValue = arr.push(3,4,5);
console.log(arr); // [1,2,3,4,5]
console.log(returnValue) // 5

### pop()，删除并返回数组的最后一个元素***，若该数组为空，***

### ***则返回undefined。***原数组改变。***

```
let arr = [1,2,3];
let del = arr.pop();
console.log(arr); // [1,2]
console.log(del); // 3
```

### unshift()*向数组的开头添加一个或多个元素，并返回新的数组长度。原数组改变***

```
let arr = [1,2,3];
let returnValue = arr.unshift(4,5);
console.log(arr); // [4,5,1,2,3]
console.log(returnValue) // 5
```

### shift()**删除并返回数组的第一个元素，若该数组为空，则返回undefined。原数组改变。*

```
let arr = [1,2,3];
let del = arr.shift();
console.log(del);//1
```

### concat()**合并两个或多个数组，生成一个新的数组。原数组不变***

```
let arr = [1,2];
let b = [3,4];
let result = arr.concat(b);
console.log(result) // [1,2,3,4];
```

### reverse()**将数组倒序。原数组改变**

```
let arr = [1,2,3,4];
arr.reverse();
console.log(a); // [4,3,2,1]
```

### sort()对数组元素进行排序，根据字符串UniCode码排序，原数组改变



```
let arr = [1,2,4,3];
// 升序
arr.sort((a,b)=>{
    return a - b;
});
// 降序
arr.sort((a,b)=>{
    return b - a;
})
```

**原理**

1. **当返回值为负数时，那么前面的数在前面，也就是不动**
2. **当返回值为正数时，那么后面的数在前**
3. **为0，不动**

### join()

***将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。***

```
let arr = [1,2,3,4];
let str = arr.join();
let str1 = arr.join('-');
console.log(str); // 1,2,3,4
console.log(str1); // 1-2-3-4
```

### toString()

***此方法将数组转化为字符串***

```
let arr = [1, 2, 3, 4, 5];
let str = arr.toString()
console.log(str)// 1,2,3,4,5
```

### slice()**slice(start,end).从start开始，end之前结束，不到end。不改变原数组**

```
let a = ['项目一','项目二','项目三']
let arr = arr.slice(0,2);
console.log(a); // ["项目一","项目二","项目三"]
console.log(arr); // ["项目一","项目二"]
```

### splice()***splice(start, number, item, item) 从start开始删除number位，***

### ***然后将后面参数插入数组。返回删除元素组成对数组，会改变原数组***

```
let arr = [1,2,3];
let result = arr.slice(1,0,33);
console.log(arr); // [1,2,33,3]
console.log(result); // []
 
```

### indexOf()，**来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.indexOf('项目二');
console.log(arr); // 1
```

### includes()**判断是否包含某一元素,直接返回true或者false表示是否包含元素，对NaN一样有效。**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.includes('项目一');
console.log(result) // true
```

## 循环方法

### map

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- 不改变原数组
- ***返回值是一个新的数组***

```
let testArr = ['子项0','子项1','子项2'];
let resultArr = testArr.map((item, index) => {
  return `处理·${item}`
});
console.log(resultArr);
// 结果： ["处理·子项0", "处理·子项1", "处理·子项2"]
```

### forEach

- 对数组的每个元素执行一次提供的函数。
- ***总是返回undefined。***
- 不改变原数组

```
let testArr = ['子项0','子项1','子项2'];
testArr.forEach((item, index)=>{
  return `forEach处理${item}`
});
```

### filter

- 对数组的每一项都进行***过滤***，返回符合条件的item组成的数组
- ***不会改变原数组***

```
let filterArr = ['子项0','子项1','子项2'];
let filterResult = filterArr.filter((item, index) => {
  return item === '子项0';
});
console.log(filterArr); // ["子项0", "子项1", "子项2"]
console.log(filterResult);  ["子项0"]
```

### find

- 遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined
- 不会改变数组

```
let findArr = ['子项0','子项1','子项2']
let findResult = findArr.find((item, index) => {
  return item === '子项0';
});
console.log(findResult);
// 结果为: 子项0
```

### findIndex

- ***遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。***
- ***不会改变数组对象。***

```
let findIndexArr = ['子项0','子项1','子项2'];
let findIndexResult = findIndexArr.findIndex((item, index)=>{
  return item === '子项0';
});
console.log(findIndexResult);
// 结果为： 0
```

### every

- 对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。***简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false***

```
let everyArr = [2,3,4];
let everyResult = everyArr.every((item, index)=>{
  return item > 0
});
console.log(everyResult);
// 结果为: true
```

### some

是对数组中每一项运行指定函数，如果该函数对***任一项返回true，则返回true。***

```
let someArr = [2,3,4];
let someResult = someArr.some((item, index)=>{
  return item > 3
});
console.log(someResult);
// 结果为: true
```

### reduce

- 接收一个函数作为累加器（accumulator），数组中的每个值***（从左到右）***开始缩减，最终为一个值。
- 第二个参数作为第一次调用的a的值

```
// reducer
let reduceArr = [0,1,2,3,4]
let reduceResult = reduceArr.reduce((a, b)=>{
  return a + b;
});
console.log(reduceResult);
// 结果: 10
```

### reduceRight

- 和reduce一样是累加器，不过是***从右往左计算***
- 第二个参数作为第一次调用的a的值



## 闭包

答：闭包说的通俗⼀点就是打通了⼀条在函数外部访问函数内部作⽤域的通道。正常情况下函数外部是
访问不到函数内部作⽤域变量的，
表象判断是不是闭包:函数嵌套函数,内部函数被 return 内部函数调⽤外层函数的局部变量
优点：可以隔离作⽤域，不造成全局污染
缺点：由于闭包⻓期驻留内存，则⻓期这样会导致内存泄露
如何解决内存泄露：将暴露全外部的闭包变量置为 null
适⽤场景：封装组件，for 循环和定时器结合使⽤,for 循环和 dom 事件结合.可以在性能优化的过程中,节流
防抖函数的使⽤,导航栏获取下标的使⽤。

## 原型和原型链

#### 原型

通常，我们写一个构造函数都是这样：

注意: 构造函数的首字母一定是大写的

```js
function Person () {
    //...
}

```

我们不在这个构造函数里写任何代码，当我们在浏览器控制台通过`console.dir`打印出这个构造函数时，可以看到它被添加了一个属性`prototype`。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0be9dc80817b4cf79818c0718a5775b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

**构造函数`Person(潘森)`通过`prototype`属性就能访问到它的原型对象，`Person.prototype`就是原型对象** ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3028f79561d7479fad2e5046b93c75c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

当我们需要通过`Person`构造函数创建一个实例时，通常是这么写：

```js
function Person () {
    //...
}
const person = new Person() // 通过new操作符创建一个实例
console.log(person instanceof Person) // true
```

那么`person`实例可以访问`Person`构造函数的原型对象吗? 显然是可以的。

通过new创建的实例上有一个`__proto__`属性（注意⚠前后是两个下划线）可以直接访问原型对象`Person.prototype`。通常，我们将`__proto__`属性称为**隐式原型属性**。

如下图所示 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cce3b382a18b49748a9ff9e103276b07~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

在原型上定义的属性和方法，在实例上能够继承这些属性和方法。

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype) // true
复制代码
```

此外，如果原型对象`Person.prototype`需要访问它原来的构造函数可以通过`constructor`属性，如下图所示

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf50095d54cd47a6a681a27df9ee501e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype)   // true
console.log(Person.prototype.constructor === Person) // true
复制代码
```

#### 原型链

当我们需要读取实例上的属性时，JS会先在当前实例上查找是否有该属性，如果没有则通过`__proto__`访问原型去查找是否有该属性，如果有的话就可以直接使用，没有的话，就会再通过`__proto__`去访问原型的原型，因为原型也是一个对象嘛。

`Person.prototype`可以看做是`Object`的实例，这样的话`Person.prototype`通过`__proto__`访问的是`Object`的原型`Object.prototype`，`Object.prototype`也有一个`__proto__`属性，只不过这次不套娃了，它指向的是`null`。

**总结一下：当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**

如下图所示： ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67aed29f79db452c9516589a575ff0ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

上面提到的：`Person.prototype`可以看做是`Object`的实例。

其实我们在JS中创建的对象都是`Object`的实例，他们都会继承`Object`原型对象上的属性和方法，并且 `创建的对象.__proto__ === Object.prototype`

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.toString)  // ƒ toString() { [native code] }，toString是继承Object.prototype上的方法

const obj2 = new Object()
console.log(obj2.__proto__ === Object.prototype) // true
console.log(obj2.toString) // ƒ toString() { [native code] }
复制代码
```

既然`Person.prototype`可以看做是Object的实例。那么就可以在Object处引出一个箭头指向`Person.prototype`，表示通过new创建一个实例对象。

最后，再把节点和连线调整一下，最终得到的图如下所示

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba8bb2b3b134c5681eea31bc3c1a8db~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

总结：

什么是原型？

**原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**

什么是prototype?

   **显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。**

什么是 __ proto __ ?

**可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.**

什么是构造函数？

**构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用**

什么是原型链？

**当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**



## this的理解和指向

在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
如果没有调用者，就指向全局对象 window。

1. 构造函数
   构造函数里的 this 指向实例化对象
2. 箭头函数
   箭头函数里没有 this，用的 this 是上层所在环境的 this
3. 函数是对象的属性
   this 指向这个对象
4. dom 节点调用一个事件 就指向这个 dom
5. 全局调用 就指向 widnow
6. 计时器里的 this 永远指向 window

## 多维变一维

#####  利用循环每个元素把得到的元素push新数组

  let a=[[4,5],[6,7]]

  let b=[]

  a.forEach(item=>{

​    item.forEach(val=>{

​      b.push(val)

​    })

  })

  console.log(b);

  // 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维数组。

#####  该方法返回一个新数组，对原数据没有影响。

  let data=[1,2,3,[4,5],11,22,[88,99]]

  let res=data.flat(2)

  console.log(res);

# 浅拷贝和深拷贝

浅拷贝 只拷贝一层 如果是复杂数据类型 就复制地址
深拷贝 不管这个对象有多少层 都会拷贝到值而不是地址

常见的浅复制有哪些：展开运算符 concat Object.assign
let arr2 = [...arr];
let arr2 = arr.concat();
let arr2 = Object.assign({}, arr);

深拷贝

JSON.parse(JSON.stringify())

递归 

实现 
先定义一个函数作为递归函数，然后定义一个空对象保存复制之后的结果，用for in 循环这个对象，然后进行判断如果是基本数据类型就直接复制，如果是对象就再执行这个递归函数

# JS 常见的几种继承方式以及优缺点。

- ### 1、原型继承

  实现：

  ```js
  function Super(){ this.a=1 }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){}
  Sub.prototype = new Super()
  
  const test = new Sub()
  console.log( test.say() )// hhh
  ```

  优点：通过原型继承多个引用类型的属性和方法

  缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。如下

  ```js
  function Super(){ this.a=[1,2] }
  function Sub(){}
  Sub.prototype = new Super()
  
  const test1 = new Sub()
  test1.a.push(3)
  console.log(test1.a)// [1,2,3]
  const test2 = new Sub()
  console.log(test2.a)// [1,2,3]
  ```

  ### 2、盗用构造函数

  实现：构造函数模式+call

  ```js
  function Super = function(){ this.a = 1 }
  function Sub = function(){
         Super.call(this)
         this.b = 2
  }
  
  const test = new Sub() 
  ```

  优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染

  缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法

  ### 3、组合继承

  实现：原型继承+盗用构造函数继承

  ```js
  function Super(){ this.a=[1,2] }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){
      Super.call(this)
      this b=2
  }
  Sub.prototype = new Super()
   
  const test1 = new Sub()
  console.log( test1.say() )// hhh
  test1.a.push(3)
  console.log(test1.a)// [1,2,3]
  const test2 = new Sub()
  console.log(test2.a)// [1,2]
  ```

  优点：集合了【原型继承】和【盗用构造函数继承】的优点

  缺点：存在效率问题，Super始终会被调用两次

  ### 4、原型式继承

  实现：

  es5之前

  ```js
  const obj = { a:1 }
  function createObj(o){
      const Fn(){}
      Fn.prototype = o
      return new Fn()
  }
  
  const test = createObj(obj)
  ```

  es5之后

  ```js
  const obj = { a:1 }
  
  const test = Object.create(obj)
  ```

  优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

  缺点：无法判断实例的构造函数是父类还是子类

  ```js
  const obj = { a:[1,2], b:2 }
  const test1 = Object.create(obj)
  const test2 = Object.create(obj)
  
  test1.a.push(3)
  test1.b=3
  console.log(test1.a, test2.a)// [1,2,3]  [1,2,3]
  console.log(test1.b, test2.b)// 3 2
  ```

  ### 5、寄生式继承

  实现：构造函数模式+工厂模式

  ```js
  function createObj(o){
      let clone = objectCopy(o)
      clone.say=function(){
          console.log(‘hhh’)
      }
      return clone
  }
  
  const obj = { a:1 }
  const test = createObj(obj)
  ```

  优点：根据一个对象克隆创建另一个对象，并增强对象

  缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

  注意：objectCopy不是原生接口，是自定义方法，对入参对象进行复制

  ### 6、寄生式组合继承

  实现：盗用构造函数继承 + 原型式继承

  function Super(){ this.a=[1,2] }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){
      Super.call(this)
      this b=2
  }

  Sub.prototype = Object.create(Super.prototype)
  Sub.prototype.constructor = Sub

  const test = new Sub()

# 同步异步 宏任务 微任务 事件循环***

在 js 中 任务的执行模式有两种 同步（log，for 循环等等） 和 异步（ajax 请求 计时器等）
在异步任务中 又将任务分成了宏任务和微任务，宏任务（计时器，ajax 请求）是浏览器发起的 微任务（promise.then）是 js 自身发起的 在异步任务中 微任务先执行 宏任务后执行

所以任务的执行顺序是：

同步先执行-》异步里的微任务-》异步里的宏任务

promise 本身是一个同步 then 是一个异步的微任务

事件循环 event loop

1. 整个 script 标签是一个宏任务 最开始的时候 会执行整体代码
2. 进行同步任务和异步任务的区分
3. 同步任务直接执行 异步任务进行微任务和宏任务的划分
4. 同步执行完了 执行微任务队列里的微任务 完成后再执行宏任务队列里的宏任务
5. 直到执行完成就进行下一次轮回

# day4 Es6

## 获取DOM获取节点

1. 通过ID获取节点 【返回具体某个节点】
document.getElementById(ID名)
2. 通过标签名获取节点 【返回节点数组，即使只有一个】
    document.getElementsByTagName(标签名)
3. 3.通过标签的name值获取节点 【返回节点数组】
    document.getElementsByName(Name名)
4. 通过class值来获取节点 【返回节点数组】
    document.getElementsByClassName(Class名)
5. 根据选择器返回找到结果集中的第一个
    document.querySelect(“选择器”)
6. 根据选择器返回找到的结果集，是个节点数组
    document.querySelectAll(“选择器”)
7. 获取html的方法(document.documElement)
8. 获取body的方法(document.body)

## 数组和伪数组的区别

- 伪数组的定义

  - 拥有`length`属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)

  - 不具有数组所具有的方法

    所谓真数组，其实可以直接称为：数组。
    当一个对象具有以下特点时，可以称为数组：

    可以按照索引的方式，存储多个数组
    具有length属性，表示数组内数据的长度（个数）
    对象的原型属性__proto__，指向Array类，且可以使用Array的原型对象prototype身上的属性和方法，如：push，pop等。如图1：

常见的伪数组有：函数参数arguments，DOM对象列表(例如document.querySelectorAll('div'))，jQuery中的$('div')等
Array.prototype
伪数组没有Array.prototype，它只是一个对象
数组有Array.prototype，他是对象的同时，也是数组
索引（index）和长度（length）
伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
数组的索引和长度是内置属性定义：

## 将伪数组转成真数组

**方法1:遍历：创建一个空数组，循环遍历伪数组，将遍历出的数据逐一放在空数组中**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [];           // 先创建空数组
for(var i=0;i<ali.length;i++){  // 循环遍历伪数组
    arr[i] = ali[i];    // 取出伪数组的数据，逐个放在真数组中
}

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法2:使用slice方法：利用Array原型对象的slice方法，配合apply，将slice中的this指向伪数组**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.prototype.slice.apply(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法3:利用ES6提供的Array的from方法**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.from(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法4:利用ES6提供的展开运算符（…）**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [...ali];

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法5:利用原型的复制：将伪数组的__proto__复制为Array的prototype。但是这种方法有局限性**

## arguments

###### **arguments是一个类似于数组的对象，对应于传递给函数的参数**，他有length属性，arguments[ i ]来访问对象中的元素，但是它不能用[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)的一些方法。例如push、pop、slice等。

arguments虽然不是一个数组，但是它可以转成一个真正的数组。

function argText(a,b,c){
    var actual = arguments.length;   //实际传参个数
    var hope = argText.length   //期望传参个数
    console.log(actual,hope);
    //转换数组：
    var args = [].slice.call(arguments);   //第一种
    var args = Array.prototype.slice.call(arguments);   //第二种
    let args = Array.from(arguments);   //第三种
    let args = [...arguments];   //第四种
    console.log(args)
}
argText(1,2)
//输出: 2 3   

每一个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式" [ ] "引用arguments的元素。

arguments.length为函数实参个数，arguments.callee引用函数自身。

arguments对象是所有函数中可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此参数包含传递给函数的每个参数条目。

arguments.callee：Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。

function argText(){  

  var e = arguments.callee.toString();    console.log(e); } 

argText(); 

##### **6.arguments.caller：指向调用当前函数的函数**

function argText(){
    if(argText.caller){
        var caller = argText.caller.toString();
        console.log(caller);
    }else{
        console.log("no caller");
    }  
}
function handler(){
    argText();
}
function copyHandler(){
    handler();
}
argText()
//输出: no caller
handler()
//输出: function handler(){argText();}
copyHandler();     
//输出: function handler(){argText();}   

## let

1.变量不能重复声明

2.块级作用域 全局，函数，eval

3.不存在变量提升

4.不影响作用域链

5.当let变成var后，变量会变成全局变量，所以最终的值会变化

## const

特点：

1.声明一个常量，且不可更改，一般常量用大写

2.块级作用域

3.生命的基本数据类型不可更改，复杂数据类型值可以改，

复杂数据类型只修改了堆中间的内容，栈没用变

## 结构赋值

1.数组结构，以下标来进行结构，有序结构，不能单独结构一个值

2.对象结构，以属性名进行结构，可以单独结构任何一个属性

## 模版字符串

原生js的模版字符串用··拼接

## 对象的简化写法

 let name ="赚钱"

  let hope=function(){

​    console.log('赚钱666');

  }

  const PERSION={

​    name, hope,

  }

## 箭头函数

1.可以省略小括号，当形参且只有一个的时候

2.可以省略花括号，当代吗只有一句语句return必须省略，而且语句的执行结果就是函数的返回值

## 函数参数的默认值

1.形参初始化，具有默认值的参数，一般位置要靠后(潜规则)

2.和结构赋值结合

##  rest参数

​    // 1、rest参数(形式为"…变量名"),用于获取函数的多余参数,这样就不需要使用arguments(参数)对象了.

​    // 2、rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.

​    function add(...a) {

​      let sum = 0;

​      for (var val of a) {

​        sum += val;

​      }

​      return sum

​    }

​    let sum = add(2, 5, 3);//10

​    console.log(sum);

​    // add函数是一个求和函数,利用rest参数,可以向该函数传入任意数目的参数.

​    // 3. rest参数代替arguments变量

​    function sortNumbers() {

​      return Array.prototype.slice.call(arguments).sort();

​    }

​    // rest参数的写法

​    const sortNumbers = (...numbers) => numbers.sort();

​    //4、 res参数中的变量代表一个数组,所以数组特有的方方都可以用于这个变量.下面是一个利用rest参数改写数组push方法的例子

​    function push(array, ...items) {

​      //forEach为每一个

​      items.forEach(function (item) {

​        array.push(item);

​        console.log(item);

​      });

​    }

​    var a = [];

​    push(a, 1, 2, 3);

​    // 5、rest参数之后不能再有其他参数(即只能是最后一个参数), 否则会报错.

​    // 6、函数的length属性, 不包括rest参数

## 扩展运算符

扩展运算符概念: ...扩展运算符将数组转化为,逗号分割的【参数序列】

 1.应用在数组的合并

2.将伪数组转为数组

3.数组的克隆

原生js用逗号的字符串 join(',')

## Symbol

Symbol是es6新增基本数据类型，具有唯一性，不能与其他类型运算

# day5

## 1.Promise

prominse函数是解决异步编程问题产生,所谓promise,简单说就是一个容器,里面保存着某个未来才会结束的事件从语法上说,promise是一个对象,从它可以获取异步操作的消息，prominse提供统一的API,各种异步操作都可以用同样的方法通过进行处理

## Promise出现的原因：

1.为了解决异步回调地狱问题（第三方回调是不是只执行一次，性能，和多次执行。

2.为了解决信任问题

3.为了解决回调执行顺序问题

4.为了捕捉错误能力

## 特点：

1.有三种状态：pedding(等待中) fulfilled(已成功) rejected(已失败)
一旦状态改变,就不会再变,任何时间都可以得到这个结果 如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果,这与事件(eventloop)完全不同,事件的特点是，如果你错过了它，再去监听,是得不到结果的
promise的返回值无论是不是promise函数,最终都会被封装promise函数进行返回,需要我们用then方法
概念:promise是一个容器,里面存放着异步事件
语法：promise是一个对象,可以获取异步操作的消息
2.状态的变化：
2.1 从等待中到已成功(pedding -> fulfilled)
2.2 从等待中到已失败(pedding -> rejected)
3.一旦状态确定,便不在更改,状态凝固--->resolved 无论什么时候都监听我 我就是这个样子
4.和事件循环的区别
事件循环一旦错过,不会再被监听到
promise状态凝固,永远都可以被监听到
5.promise的回调参数
1.resolve->成功的回调
2.reject-> 失败的回调
 // 实例化promise对象
    let a = new Promise((resolve, reject) => {
        setTimeout(() => {
            // let data='我要休息了'
            // resolve(data)

            let data1 = '错误信息'
            reject(data1)
        })
    })
    a.then(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);
    }) 
    // 1.实例化promise函数
    // 2. 通过 new xmlhttoprequest 实例化连接对象
    // 3.确定请求方式,以及请求的接口路径
    // 4.发送请求
    // 5.绑定事件,处理响应结果
    // 6.prominse函数的调用
    
    /**实例化promise函数*/
    const p = new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest()
        //  创建初始化链接
        xhr.open('GET', 'https://elm.cangdu.org/v1/users/count')
        // 确定请求方法和接口
        xhr.send()
        // 发送
        xhr.onreadystatechange = function () {
            // 处理响应结果
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    // 判断响应码 200-299
                    resolve(xhr.response)
                    //   成功
                } else {
                    reject(xhr.response)
                    // 失败
                }
            }
        }
    })
    p.then(res => {
        console.log(res);
    }, (err) => {
        console.log(err);
    })const fs=require('fs')
const p=new Promise((resolve, reject) => {
    fs.readFile('./为学.md',(err,data)=>{
        if(err) reject(err)
       resolve(data)
    })

 p.then(res=>{

​    console.log(res);

  },(err)=>{

​    console.log(err);

  })

# day6

## Promise方法

#### 1.then 成功的回调

#### 2..catch 

 2.1在链式调试中，catch只捕捉第一个then返回的错误信息

2.2在链式调试中，想要单独捕捉每个then的错误信息，需要每个then后面跟随catch  来进行捕获

#### 3.all   

 语法:Promise.all([p1,p2,p3]).then(res=>{res=>console.log(res)})

特点：1.接受的参数为数组[],2.返回值为一个数组，进行最终的结果

3.必须等待全部参数函数返回成功后，才会执行，不能单独获取任何一个函数的值

#### 4.race 

 语法:Promise.race  ([p1,p2,p3]).then(res=>{res=>console.log(res)})

特点：1.接受的参数为数组[],2.返回值为一个数组，进行最终的结果

3.谁先执行完，返回谁，状态就是谁

#### 5.finally  无论成功或失败都会执行

## 链式调用

1.可以一直.then下去，每个then不会相互阻碍

2.在其中一个then里面return一个值，下一个then里面可以获取到当前的值

## async和await

async快速创建一个异步函数，且基于Promise封装函数。

在函数的开头加上async可成为一个异步函数，在异步函数中返回Promise之前使用的await关键字。

特点:1.await不能单独使用，必须在async定义的函数内部使用

2.获取错误信息需要使用try{}来进行获取，try内部写代码块，catch 获取错误信息，catch捕捉到最后哥返回的错误信息

## Map对象

概念：为了提供更多数值类型的值，扩宽Object只能使用字符串作为键的延伸

方法: 1.使用new Map() ，2.判断长度：map.size(尺寸，长度)，3.添加元素：map.set( )

4.获取键值:map.get，    5.判断当前对象中不存在该属性：map.has

6.删除当前对象中的属性:map.delete，   7.清空该方法的所有成员:map.clear

## Set数组

概念：新建一个数组，且保证数组中每个值都是唯一的

语法:let a = new Set( )

方法: 1.判断长度：array.size(尺寸，长度)，3.添加元素：array.add( )

  5.判断当前是否中存在该值：array.has( )

6.删除元素:array.delete，   7.清空:array.clear

## Set.prototype.keys()：返回键名的遍历器

## Set.prototype.values()：返回键值的遍历器。

## Set.prototype.entries()：返回键值对的遍历器。

## Set.prototype.forEach()：使用回调函数遍历每个成员。

## 以上都是Set自带的方法

let set = new Set([1, 2, 3, 4])

console.log(set);

for (let item of set) {

  console.log(item);

  //返回键值的遍历器

}

for (let item of set.keys()) {

  console.log(item);

  // 返回键名的遍历器

}

for (let item of set.values()) {

  console.log(item);

  //返回键值的遍历器

}

for (let item of set.entries()) {

  console.log(item);

  //返回键值的遍历器

}

set.forEach((key, value) => {

  console.log(key + ':' + value);

})



