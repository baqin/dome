# 第一天git

## 常见的版本控制工具

主流的版本控制器有如下这些：    

Git（重要） 

SVN（Subversion）（重要）

CVS（Concurrent Versions System）

VSS（Micorosoft Visual SourceSafe）

TFS（Team Foundation Server） 

Visual Studio Online

## 集中版本控制svn

所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改,集中式版本控制，需要联网才行

缺点: 1. 所有的历史代码都存放在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回

优点: 1. 个人本地占用储存空间较小,只需要保存自己修改的内容即可

分布式版本控制 Git

每个人都拥有全部的代码，可以在本地提交，联网之后push到远程仓库就行，只要有一个用户数据没问题，就可以恢复所有数据。

优点：不会因为服务器损坏或者网络问题，造成不能工作的情况！

缺点：增加了本地存储空间的占用

## 启动git

Git Bash ：Unix与Linux风格的命令行，使用最多，推荐最多

Git CMD：Windows风格的命令行

Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

Git区域

Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。

## 常用的Linux命令

平时一定要多使用这些基础的命令！

1）cd : 进入目录。

2）cd . . 回退到上一个目录，直接cd进入默认目录

3）pwd : 显示当前所在的目录路径。

4）ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）

5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。

6）rm: 删除一个文件, rm index.js 就会把index.js文件删除。

7）mkdir: 新建一个目录,就是新建一个文件夹。

8）rm -r : 删除一个文件夹, rm -r src 删除src目录

9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。

10）reset 重新初始化终端/清屏。

11）clear 清屏。

12）history 查看命令历史。

13）help 帮助。（Mac除外）

14）exit 退出。

15）#表示注释

16) ls: 查看桌面的所有文件

## Git文件四种状态

Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.

Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件

Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !

Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified

## 本地仓库搭建

1、创建全新的仓库，需要用GIT管理的项目的根目录执行：

\# 在当前目录新建一个Git代码库$ git init

2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。

1:windows查看隐藏文件夹 在查看里面勾选

2:mac查看隐藏文件夹 

## 克隆远程仓库

1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！

\# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]

# 第二天es6

## JS数据类型

1. ***基本数据类型***

number、string、undefined、null、boolean、symbol、bigint

2. ***引用数据类型【对象类型】***

(1) 标准普通对象: object

(2) 标准特殊对象： Array、RegExp、Date、Math、Error...

(3) 非标准特殊对象：Number、String、Boolean...

(4) 可调用对象/执行对象：function

##  JS数据类型转换

#  -------1.Number

Js中的数据类型转换有两种模式，**一种是隐式转换，一种是显示转换**。

<u>**隐式转换**</u>：*浏览器默认去转换，用**Number()***

**①Number**
转换规则：
1.字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN

2.布尔值转换为数字:true–>1,false–>0

3.null–>0,undefined–>NaN

4.Symbol无法转换为数字，会报错:Uncaught TypeError: Cannot convert a Symbol value to a number

 5.BigInt去除"n"

6.把对象转换为数字

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串
- 最后再把字符串基于Number方法转换为数字

 ②**parseInt与parseFloat**

parseInt(val,radix)接受两个参数

- 第一个参数val必须是字符串，如果不是，要先隐式转换为字符串，调用String()
- 第二个参数radix表示进制，如果不写，或者写0，则默认是10进制

#### 2.String

**情景1：String(val)或者val.toString()**
***转换规则：除对象以外，都是直接用字符串包起来**

对象转字符串的转换规则，与对象转数字的规则一样：

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串

**情景2：加号+**
***除了数学运算，还可能代表字符串拼接，也会发生字符串转换***

**（1）+有两边，一边是字符串或者某些对象**

console.log(10+'10');	//'1010'

按对象转字符串的转换规则
先new Date()[Symbol.toPrimitive] (‘default’)—>‘Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)’
得到字符串，然后拼接上10—>‘10Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)

- 先[10] [Symbol.toPrimitive]—>undefined
- 然后[10].valueOf()—>[10]

- 再然后[10].toString()—>‘10’

- 最后10+'10’字符串拼接—>‘1010’

#### 3.Boolean

**转换规则：**
***除了“0/NaN/空字符串/null/undefined"五个值是false，其余值都是true***
情景：

- Boolean(val)
- !/!! （！表示取反，！！表示取反再取反，所以！！跟Boolean()是一个意思）
- 条件判断

4.比较时的相互转换规则

**情景1：对象==字符串**
***按对象转字符串规则Symbol.toPrimitive—>valueOf—>toString***
***将对象转成字符串，然后比较***

**情景2：null==undefined**

​	console.log(null==undefined);//true

console.log(null===undefined);//false

**情景3：对象==对象**
***比较的是堆内存地址，地址相同则相等***

**情景4：NaN**

console.log(NaN==NaN);//false
	console.log(NaN===NaN);//false

NaN与任何值都不相等,包括NaN本身

情景5：***除了以上情景，只要两边类型不一致，剩下的都是转换数字，然后再进行比较***
***"==="绝对相等,如果两边类型不同，则直接是false，不会发生数据类型转换。***
例1：console.log([]==false);	//true

# 检测数据类型

### **1.typeof**

***typeof 返回对应类型的字符串***

***总结：typeof 检测基本数据类型比较准，null检测为object不代表它是引用数据类型，null为空是特殊的基本数据类型，引用数据类型都为 object，内置构造函数和函数都为 function***

### 2.instanceof

 ***instanceof 检测类型返回布尔值***

***总结：instanceof 不能检测基本数据类型，判断前者的 proto 是否在后者的原型对象上***

### 3.constructor

***constructor 返回构造函数***

***总结：返回当前值的构造函数，比如向 [] 数组这种，都是通过 new Array() 这样去创建实例的，这个 Array 就是数组的构造函数***

### 4.Object.prototype.toString.call()

***总结：这个方法查的特别的准，可以检查任意类型***

### 5.Object.getPrototypeOf()

// 获取原型，和想要的原型做对比
console.log(Object.getPrototypeOf([]) === Array.prototype); // true
console.log(Object.getPrototypeOf({}) === Object.prototype); // true

### 五种方法的总结**

- ***typeof：这种方法只能检测基本数据类型，null 和对象的不准***

- ***instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型***

- ***constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷***

- ***Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测***

- ***Object.getPrototypeOf()：这种方法获取原型***

  # 作用域及作用域链

  - 所谓作用域通俗点讲就是变量的可作用范围。
  - 一般有三种作用域。全局，函数，块。

## 变量提升及函数提升

##### 什么是变量提升？

变量提升是指将变量声明提升到它所在的作用域的最开始部分

## 什么是函数提升

 创建函数有两种形式，一种是函数声明，另外一种是函数字面量，**只有函数声明才有变量提升**

## 函数提升与变量提升的优先级

**由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。**

# 运算符

### 1.数学运算符

数学运算符就是常见的**加(+)、减(-)、乘(*)、除(/)、等于(=)、求幂(**)、**自增(++)、自减(--)、加等于(+=)、减等于(-=)**等

### 2.比较运算符

与数学运算中的比较相同**：大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)**等；注意: **全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样**；

### 3.三元表达式

三元表达式可以替代简单的if条件，**表达式为判断条件 ？条件为真 ：条件为假**。

if（3 > 4）{
    console.log("条件为真");
}else {
    console.log("条件为假");
}
// 三元表达式 —— 代码更加简洁清晰
3 > 4 ? console.log("条件为真") : console.log("条件为假")

### 4.短路运算符 && 与 ||

**短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了。**

- &&：从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值；

- || ：为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值；

  // 1.利用||设置默认值，防止代码出错。

  // 假设data需要取出后台返回的context数组,但返回中不包含context，便可以使用||防止找不到对应值而报错。

  const data = res.context || [];
  // 2.利用&&来省略简单if判断,例如：当某一条件为真时执行函数
  if(1 < 2) {
      fn()
  }
  // 可以简写为
  (1 < 2) && fn()

# day3 JS部分

## 数组方法

### isArray() ，判断是不是一个数组

let arr = [1,2];
console.log(arr.isArray()); //true

### push()，向数组***末尾添加***一个或者多个元素，

### ***返回新数组到长度**。**会改变原数组***

let arr = [1,2];
let returnValue = arr.push(3,4,5);
console.log(arr); // [1,2,3,4,5]
console.log(returnValue) // 5

### pop()，删除并返回数组的最后一个元素***，若该数组为空，***

### ***则返回undefined。***原数组改变。***

```
let arr = [1,2,3];
let del = arr.pop();
console.log(arr); // [1,2]
console.log(del); // 3
```

### unshift()*向数组的开头添加一个或多个元素，并返回新的数组长度。原数组改变***

```
let arr = [1,2,3];
let returnValue = arr.unshift(4,5);
console.log(arr); // [4,5,1,2,3]
console.log(returnValue) // 5
```

### shift()**删除并返回数组的第一个元素，若该数组为空，则返回undefined。原数组改变。*

```
let arr = [1,2,3];
let del = arr.shift();
console.log(del);//1
```

### concat()**合并两个或多个数组，生成一个新的数组。原数组不变***

```
let arr = [1,2];
let b = [3,4];
let result = arr.concat(b);
console.log(result) // [1,2,3,4];
```

### reverse()**将数组倒序。原数组改变**

```
let arr = [1,2,3,4];
arr.reverse();
console.log(a); // [4,3,2,1]
```

### sort()对数组元素进行排序，根据字符串UniCode码排序，原数组改变



```
let arr = [1,2,4,3];
// 升序
arr.sort((a,b)=>{
    return a - b;
});
// 降序
arr.sort((a,b)=>{
    return b - a;
})
```

**原理**

1. **当返回值为负数时，那么前面的数在前面，也就是不动**
2. **当返回值为正数时，那么后面的数在前**
3. **为0，不动**

### join()

***将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。***

```
let arr = [1,2,3,4];
let str = arr.join();
let str1 = arr.join('-');
console.log(str); // 1,2,3,4
console.log(str1); // 1-2-3-4
```

### toString()

***此方法将数组转化为字符串***

```
let arr = [1, 2, 3, 4, 5];
let str = arr.toString()
console.log(str)// 1,2,3,4,5
```

### slice()**slice(start,end).从start开始，end之前结束，不到end。不改变原数组**

```
let a = ['项目一','项目二','项目三']
let arr = arr.slice(0,2);
console.log(a); // ["项目一","项目二","项目三"]
console.log(arr); // ["项目一","项目二"]
```

### splice()***splice(start, number, item, item) 从start开始删除number位，***

### ***然后将后面参数插入数组。返回删除元素组成对数组，会改变原数组***

```
let arr = [1,2,3];
let result = arr.slice(1,0,33);
console.log(arr); // [1,2,33,3]
console.log(result); // []
 
```

### indexOf()，**来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.indexOf('项目二');
console.log(arr); // 1
```

### includes()**判断是否包含某一元素,直接返回true或者false表示是否包含元素，对NaN一样有效。**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.includes('项目一');
console.log(result) // true
```

## 循环方法

### map

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- 不改变原数组
- ***返回值是一个新的数组***

```
let testArr = ['子项0','子项1','子项2'];
let resultArr = testArr.map((item, index) => {
  return `处理·${item}`
});
console.log(resultArr);
// 结果： ["处理·子项0", "处理·子项1", "处理·子项2"]
```

### forEach

- 对数组的每个元素执行一次提供的函数。
- ***总是返回undefined。***
- 不改变原数组

```
let testArr = ['子项0','子项1','子项2'];
testArr.forEach((item, index)=>{
  return `forEach处理${item}`
});
```

### filter

- 对数组的每一项都进行***过滤***，返回符合条件的item组成的数组
- ***不会改变原数组***

```
let filterArr = ['子项0','子项1','子项2'];
let filterResult = filterArr.filter((item, index) => {
  return item === '子项0';
});
console.log(filterArr); // ["子项0", "子项1", "子项2"]
console.log(filterResult);  ["子项0"]
```

### find

- 遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined
- 不会改变数组

```
let findArr = ['子项0','子项1','子项2']
let findResult = findArr.find((item, index) => {
  return item === '子项0';
});
console.log(findResult);
// 结果为: 子项0
```

### findIndex

- ***遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。***
- ***不会改变数组对象。***

```
let findIndexArr = ['子项0','子项1','子项2'];
let findIndexResult = findIndexArr.findIndex((item, index)=>{
  return item === '子项0';
});
console.log(findIndexResult);
// 结果为： 0
```

### every

- 对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。***简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false***

```
let everyArr = [2,3,4];
let everyResult = everyArr.every((item, index)=>{
  return item > 0
});
console.log(everyResult);
// 结果为: true
```

### some

是对数组中每一项运行指定函数，如果该函数对***任一项返回true，则返回true。***

```
let someArr = [2,3,4];
let someResult = someArr.some((item, index)=>{
  return item > 3
});
console.log(someResult);
// 结果为: true
```

### reduce

- 接收一个函数作为累加器（accumulator），数组中的每个值***（从左到右）***开始缩减，最终为一个值。
- 第二个参数作为第一次调用的a的值

```
// reducer
let reduceArr = [0,1,2,3,4]
let reduceResult = reduceArr.reduce((a, b)=>{
  return a + b;
});
console.log(reduceResult);
// 结果: 10
```

### reduceRight

- 和reduce一样是累加器，不过是***从右往左计算***
- 第二个参数作为第一次调用的a的值



## 闭包

答：闭包说的通俗⼀点就是打通了⼀条在函数外部访问函数内部作⽤域的通道。正常情况下函数外部是
访问不到函数内部作⽤域变量的，
表象判断是不是闭包:函数嵌套函数,内部函数被 return 内部函数调⽤外层函数的局部变量
优点：可以隔离作⽤域，不造成全局污染
缺点：由于闭包⻓期驻留内存，则⻓期这样会导致内存泄露
如何解决内存泄露：将暴露全外部的闭包变量置为 null
适⽤场景：封装组件，for 循环和定时器结合使⽤,for 循环和 dom 事件结合.可以在性能优化的过程中,节流
防抖函数的使⽤,导航栏获取下标的使⽤。

## 原型和原型链

#### 原型

通常，我们写一个构造函数都是这样：

注意: 构造函数的首字母一定是大写的

```js
function Person () {
    //...
}

```

我们不在这个构造函数里写任何代码，当我们在浏览器控制台通过`console.dir`打印出这个构造函数时，可以看到它被添加了一个属性`prototype`。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0be9dc80817b4cf79818c0718a5775b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

**构造函数`Person(潘森)`通过`prototype`属性就能访问到它的原型对象，`Person.prototype`就是原型对象** ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3028f79561d7479fad2e5046b93c75c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

当我们需要通过`Person`构造函数创建一个实例时，通常是这么写：

```js
function Person () {
    //...
}
const person = new Person() // 通过new操作符创建一个实例
console.log(person instanceof Person) // true
```

那么`person`实例可以访问`Person`构造函数的原型对象吗? 显然是可以的。

通过new创建的实例上有一个`__proto__`属性（注意⚠前后是两个下划线）可以直接访问原型对象`Person.prototype`。通常，我们将`__proto__`属性称为**隐式原型属性**。

如下图所示 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cce3b382a18b49748a9ff9e103276b07~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

在原型上定义的属性和方法，在实例上能够继承这些属性和方法。

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype) // true
复制代码
```

此外，如果原型对象`Person.prototype`需要访问它原来的构造函数可以通过`constructor`属性，如下图所示

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf50095d54cd47a6a681a27df9ee501e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype)   // true
console.log(Person.prototype.constructor === Person) // true
复制代码
```

#### 原型链

当我们需要读取实例上的属性时，JS会先在当前实例上查找是否有该属性，如果没有则通过`__proto__`访问原型去查找是否有该属性，如果有的话就可以直接使用，没有的话，就会再通过`__proto__`去访问原型的原型，因为原型也是一个对象嘛。

`Person.prototype`可以看做是`Object`的实例，这样的话`Person.prototype`通过`__proto__`访问的是`Object`的原型`Object.prototype`，`Object.prototype`也有一个`__proto__`属性，只不过这次不套娃了，它指向的是`null`。

**总结一下：当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**

如下图所示： ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67aed29f79db452c9516589a575ff0ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

上面提到的：`Person.prototype`可以看做是`Object`的实例。

其实我们在JS中创建的对象都是`Object`的实例，他们都会继承`Object`原型对象上的属性和方法，并且 `创建的对象.__proto__ === Object.prototype`

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.toString)  // ƒ toString() { [native code] }，toString是继承Object.prototype上的方法

const obj2 = new Object()
console.log(obj2.__proto__ === Object.prototype) // true
console.log(obj2.toString) // ƒ toString() { [native code] }
复制代码
```

既然`Person.prototype`可以看做是Object的实例。那么就可以在Object处引出一个箭头指向`Person.prototype`，表示通过new创建一个实例对象。

最后，再把节点和连线调整一下，最终得到的图如下所示

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba8bb2b3b134c5681eea31bc3c1a8db~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

总结：

什么是原型？

**原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**

什么是prototype?

   **显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。**

什么是 __ proto __ ?

**可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.**

什么是构造函数？

**构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用**

什么是原型链？

**当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**



## this的理解和指向

在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
如果没有调用者，就指向全局对象 window。

1. 构造函数
   构造函数里的 this 指向实例化对象
2. 箭头函数
   箭头函数里没有 this，用的 this 是上层所在环境的 this
3. 函数是对象的属性
   this 指向这个对象
4. dom 节点调用一个事件 就指向这个 dom
5. 全局调用 就指向 widnow
6. 计时器里的 this 永远指向 window

## 多维变一维

#####  利用循环每个元素把得到的元素push新数组

  let a=[[4,5],[6,7]]

  let b=[]

  a.forEach(item=>{

​    item.forEach(val=>{

​      b.push(val)

​    })

  })

  console.log(b);

  // 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维数组。

#####  该方法返回一个新数组，对原数据没有影响。

  let data=[1,2,3,[4,5],11,22,[88,99]]

  let res=data.flat(2)

  console.log(res);

# 浅拷贝和深拷贝

浅拷贝 只拷贝一层 如果是复杂数据类型 就复制地址
深拷贝 不管这个对象有多少层 都会拷贝到值而不是地址

常见的浅复制有哪些：展开运算符 concat Object.assign
let arr2 = [...arr];
let arr2 = arr.concat();
let arr2 = Object.assign({}, arr);

深拷贝

JSON.parse(JSON.stringify())

递归 

实现 
先定义一个函数作为递归函数，然后定义一个空对象保存复制之后的结果，用for in 循环这个对象，然后进行判断如果是基本数据类型就直接复制，如果是对象就再执行这个递归函数

# JS 常见的几种继承方式以及优缺点。

- ### 1、原型继承

  实现：

  ```js
  function Super(){ this.a=1 }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){}
  Sub.prototype = new Super()
  
  const test = new Sub()
  console.log( test.say() )// hhh
  ```

  优点：通过原型继承多个引用类型的属性和方法

  缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。如下

  ```js
  function Super(){ this.a=[1,2] }
  function Sub(){}
  Sub.prototype = new Super()
  
  const test1 = new Sub()
  test1.a.push(3)
  console.log(test1.a)// [1,2,3]
  const test2 = new Sub()
  console.log(test2.a)// [1,2,3]
  ```

  ### 2、盗用构造函数

  实现：构造函数模式+call

  ```js
  function Super = function(){ this.a = 1 }
  function Sub = function(){
         Super.call(this)
         this.b = 2
  }
  
  const test = new Sub() 
  ```

  优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染

  缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法

  ### 3、组合继承

  实现：原型继承+盗用构造函数继承

  ```js
  function Super(){ this.a=[1,2] }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){
      Super.call(this)
      this b=2
  }
  Sub.prototype = new Super()
   
  const test1 = new Sub()
  console.log( test1.say() )// hhh
  test1.a.push(3)
  console.log(test1.a)// [1,2,3]
  const test2 = new Sub()
  console.log(test2.a)// [1,2]
  ```

  优点：集合了【原型继承】和【盗用构造函数继承】的优点

  缺点：存在效率问题，Super始终会被调用两次

  ### 4、原型式继承

  实现：

  es5之前

  ```js
  const obj = { a:1 }
  function createObj(o){
      const Fn(){}
      Fn.prototype = o
      return new Fn()
  }
  
  const test = createObj(obj)
  ```

  es5之后

  ```js
  const obj = { a:1 }
  
  const test = Object.create(obj)
  ```

  优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

  缺点：无法判断实例的构造函数是父类还是子类

  ```js
  const obj = { a:[1,2], b:2 }
  const test1 = Object.create(obj)
  const test2 = Object.create(obj)
  
  test1.a.push(3)
  test1.b=3
  console.log(test1.a, test2.a)// [1,2,3]  [1,2,3]
  console.log(test1.b, test2.b)// 3 2
  ```

  ### 5、寄生式继承

  实现：构造函数模式+工厂模式

  ```js
  function createObj(o){
      let clone = objectCopy(o)
      clone.say=function(){
          console.log(‘hhh’)
      }
      return clone
  }
  
  const obj = { a:1 }
  const test = createObj(obj)
  ```

  优点：根据一个对象克隆创建另一个对象，并增强对象

  缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

  注意：objectCopy不是原生接口，是自定义方法，对入参对象进行复制

  ### 6、寄生式组合继承

  实现：盗用构造函数继承 + 原型式继承

  function Super(){ this.a=[1,2] }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){
      Super.call(this)
      this b=2
  }

  Sub.prototype = Object.create(Super.prototype)
  Sub.prototype.constructor = Sub

  const test = new Sub()

# 同步异步 宏任务 微任务 事件循环***

在 js 中 任务的执行模式有两种 同步（log，for 循环等等） 和 异步（ajax 请求 计时器等）
在异步任务中 又将任务分成了宏任务和微任务，宏任务（计时器，ajax 请求）是浏览器发起的 微任务（promise.then）是 js 自身发起的 在异步任务中 微任务先执行 宏任务后执行

所以任务的执行顺序是：

同步先执行-》异步里的微任务-》异步里的宏任务

promise 本身是一个同步 then 是一个异步的微任务

事件循环 event loop

1. 整个 script 标签是一个宏任务 最开始的时候 会执行整体代码
2. 进行同步任务和异步任务的区分
3. 同步任务直接执行 异步任务进行微任务和宏任务的划分
4. 同步执行完了 执行微任务队列里的微任务 完成后再执行宏任务队列里的宏任务
5. 直到执行完成就进行下一次轮回

# day4 Es6

## 获取DOM获取节点

1. 通过ID获取节点 【返回具体某个节点】
document.getElementById(ID名)
2. 通过标签名获取节点 【返回节点数组，即使只有一个】
    document.getElementsByTagName(标签名)
3. 3.通过标签的name值获取节点 【返回节点数组】
    document.getElementsByName(Name名)
4. 通过class值来获取节点 【返回节点数组】
    document.getElementsByClassName(Class名)
5. 根据选择器返回找到结果集中的第一个
    document.querySelect(“选择器”)
6. 根据选择器返回找到的结果集，是个节点数组
    document.querySelectAll(“选择器”)
7. 获取html的方法(document.documElement)
8. 获取body的方法(document.body)

## 数组和伪数组的区别

- 伪数组的定义

  - 拥有`length`属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)

  - 不具有数组所具有的方法

    所谓真数组，其实可以直接称为：数组。
    当一个对象具有以下特点时，可以称为数组：

    可以按照索引的方式，存储多个数组
    具有length属性，表示数组内数据的长度（个数）
    对象的原型属性__proto__，指向Array类，且可以使用Array的原型对象prototype身上的属性和方法，如：push，pop等。如图1：

常见的伪数组有：函数参数arguments，DOM对象列表(例如document.querySelectorAll('div'))，jQuery中的$('div')等
Array.prototype
伪数组没有Array.prototype，它只是一个对象
数组有Array.prototype，他是对象的同时，也是数组
索引（index）和长度（length）
伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
数组的索引和长度是内置属性定义：

## 将伪数组转成真数组

**方法1:遍历：创建一个空数组，循环遍历伪数组，将遍历出的数据逐一放在空数组中**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [];           // 先创建空数组
for(var i=0;i<ali.length;i++){  // 循环遍历伪数组
    arr[i] = ali[i];    // 取出伪数组的数据，逐个放在真数组中
}

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法2:使用slice方法：利用Array原型对象的slice方法，配合apply，将slice中的this指向伪数组**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.prototype.slice.apply(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法3:利用ES6提供的Array的from方法**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.from(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法4:利用ES6提供的展开运算符（…）**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [...ali];

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法5:利用原型的复制：将伪数组的__proto__复制为Array的prototype。但是这种方法有局限性**

## arguments

###### **arguments是一个类似于数组的对象，对应于传递给函数的参数**，他有length属性，arguments[ i ]来访问对象中的元素，但是它不能用[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)的一些方法。例如push、pop、slice等。

arguments虽然不是一个数组，但是它可以转成一个真正的数组。

function argText(a,b,c){
    var actual = arguments.length;   //实际传参个数
    var hope = argText.length   //期望传参个数
    console.log(actual,hope);
    //转换数组：
    var args = [].slice.call(arguments);   //第一种
    var args = Array.prototype.slice.call(arguments);   //第二种
    let args = Array.from(arguments);   //第三种
    let args = [...arguments];   //第四种
    console.log(args)
}
argText(1,2)
//输出: 2 3   

每一个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式" [ ] "引用arguments的元素。

arguments.length为函数实参个数，arguments.callee引用函数自身。

arguments对象是所有函数中可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此参数包含传递给函数的每个参数条目。

arguments.callee：Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。

function argText(){  

  var e = arguments.callee.toString();    console.log(e); } 

argText(); 

##### **6.arguments.caller：指向调用当前函数的函数**

function argText(){
    if(argText.caller){
        var caller = argText.caller.toString();
        console.log(caller);
    }else{
        console.log("no caller");
    }  
}
function handler(){
    argText();
}
function copyHandler(){
    handler();
}
argText()
//输出: no caller
handler()
//输出: function handler(){argText();}
copyHandler();     
//输出: function handler(){argText();}   

## let

1.变量不能重复声明

2.块级作用域 全局，函数，eval

3.不存在变量提升

4.不影响作用域链

5.当let变成var后，变量会变成全局变量，所以最终的值会变化

## const

特点：

1.声明一个常量，且不可更改，一般常量用大写

2.块级作用域

3.生命的基本数据类型不可更改，复杂数据类型值可以改，

复杂数据类型只修改了堆中间的内容，栈没用变

## 结构赋值

1.数组结构，以下标来进行结构，有序结构，不能单独结构一个值

2.对象结构，以属性名进行结构，可以单独结构任何一个属性

## 模版字符串

原生js的模版字符串用··拼接

## 对象的简化写法

 let name ="赚钱"

  let hope=function(){

​    console.log('赚钱666');

  }

  const PERSION={

​    name, hope,

  }

## 箭头函数

1.可以省略小括号，当形参且只有一个的时候

2.可以省略花括号，当代吗只有一句语句return必须省略，而且语句的执行结果就是函数的返回值

## 函数参数的默认值

1.形参初始化，具有默认值的参数，一般位置要靠后(潜规则)

2.和结构赋值结合

##  rest参数

​    // 1、rest参数(形式为"…变量名"),用于获取函数的多余参数,这样就不需要使用arguments(参数)对象了.

​    // 2、rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.

​    function add(...a) {

​      let sum = 0;

​      for (var val of a) {

​        sum += val;

​      }

​      return sum

​    }

​    let sum = add(2, 5, 3);//10

​    console.log(sum);

​    // add函数是一个求和函数,利用rest参数,可以向该函数传入任意数目的参数.

​    // 3. rest参数代替arguments变量

​    function sortNumbers() {

​      return Array.prototype.slice.call(arguments).sort();

​    }

​    // rest参数的写法

​    const sortNumbers = (...numbers) => numbers.sort();

​    //4、 res参数中的变量代表一个数组,所以数组特有的方方都可以用于这个变量.下面是一个利用rest参数改写数组push方法的例子

​    function push(array, ...items) {

​      //forEach为每一个

​      items.forEach(function (item) {

​        array.push(item);

​        console.log(item);

​      });

​    }

​    var a = [];

​    push(a, 1, 2, 3);

​    // 5、rest参数之后不能再有其他参数(即只能是最后一个参数), 否则会报错.

​    // 6、函数的length属性, 不包括rest参数

## 扩展运算符

扩展运算符概念: ...扩展运算符将数组转化为,逗号分割的【参数序列】

 1.应用在数组的合并

2.将伪数组转为数组

3.数组的克隆

原生js用逗号的字符串 join(',')

## Symbol

Symbol是es6新增基本数据类型，具有唯一性，不能与其他类型运算

# day5-Promise

## 1.Promise

prominse函数是解决异步编程问题产生,所谓promise,简单说就是一个容器,里面保存着某个未来才会结束的事件从语法上说,promise是一个对象,从它可以获取异步操作的消息，prominse提供统一的API,各种异步操作都可以用同样的方法通过进行处理

## Promise出现的原因：

1.为了解决异步回调地狱问题（第三方回调是不是只执行一次，性能，和多次执行。

2.为了解决信任问题

3.为了解决回调执行顺序问题

4.为了捕捉错误能力

## 特点：

1.有三种状态：pedding(等待中) fulfilled(已成功) rejected(已失败)
一旦状态改变,就不会再变,任何时间都可以得到这个结果 如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果,这与事件(eventloop)完全不同,事件的特点是，如果你错过了它，再去监听,是得不到结果的
promise的返回值无论是不是promise函数,最终都会被封装promise函数进行返回,需要我们用then方法
概念:promise是一个容器,里面存放着异步事件
语法：promise是一个对象,可以获取异步操作的消息
2.状态的变化：
2.1 从等待中到已成功(pedding -> fulfilled)
2.2 从等待中到已失败(pedding -> rejected)
3.一旦状态确定,便不在更改,状态凝固--->resolved 无论什么时候都监听我 我就是这个样子
4.和事件循环的区别
事件循环一旦错过,不会再被监听到
promise状态凝固,永远都可以被监听到
5.promise的回调参数
1.resolve->成功的回调
2.reject-> 失败的回调
 // 实例化promise对象
    let a = new Promise((resolve, reject) => {
        setTimeout(() => {
            // let data='我要休息了'
            // resolve(data)

            let data1 = '错误信息'
            reject(data1)
        })
    })
    a.then(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);
    }) 
    // 1.实例化promise函数
    // 2. 通过 new xmlhttoprequest 实例化连接对象
    // 3.确定请求方式,以及请求的接口路径
    // 4.发送请求
    // 5.绑定事件,处理响应结果
    // 6.prominse函数的调用
    
    /**实例化promise函数*/
    const p = new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest()
        //  创建初始化链接
        xhr.open('GET', 'https://elm.cangdu.org/v1/users/count')
        // 确定请求方法和接口
        xhr.send()
        // 发送
        xhr.onreadystatechange = function () {
            // 处理响应结果
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    // 判断响应码 200-299
                    resolve(xhr.response)
                    //   成功
                } else {
                    reject(xhr.response)
                    // 失败
                }
            }
        }
    })
    p.then(res => {
        console.log(res);
    }, (err) => {
        console.log(err);
    })const fs=require('fs')
const p=new Promise((resolve, reject) => {
    fs.readFile('./为学.md',(err,data)=>{
        if(err) reject(err)
       resolve(data)
    })

 p.then(res=>{

​    console.log(res);

  },(err)=>{

​    console.log(err);

  })

# day6

## Promise方法

#### 1.then 成功的回调

#### 2..catch 

 2.1在链式调试中，catch只捕捉第一个then返回的错误信息

2.2在链式调试中，想要单独捕捉每个then的错误信息，需要每个then后面跟随catch  来进行捕获

#### 3.all   

 语法:Promise.all([p1,p2,p3]).then(res=>{res=>console.log(res)})

特点：1.接受的参数为数组[],2.返回值为一个数组，进行最终的结果

3.必须等待全部参数函数返回成功后，才会执行，不能单独获取任何一个函数的值

#### 4.race 

 语法:Promise.race  ([p1,p2,p3]).then(res=>{res=>console.log(res)})

特点：1.接受的参数为数组[],2.返回值为一个数组，进行最终的结果

3.谁先执行完，返回谁，状态就是谁

#### 5.finally  无论成功或失败都会执行

## 链式调用

1.可以一直.then下去，每个then不会相互阻碍

2.在其中一个then里面return一个值，下一个then里面可以获取到当前的值

## async和await

async快速创建一个异步函数，且基于Promise封装函数。

在函数的开头加上async可成为一个异步函数，在异步函数中返回Promise之前使用的await关键字。

特点:1.await不能单独使用，必须在async定义的函数内部使用

2.获取错误信息需要使用try{}来进行获取，try内部写代码块，catch 获取错误信息，catch捕捉到最后返回的错误信息

## Map对象

概念：为了提供更多数值类型的值，扩宽Object只能使用字符串作为键的延伸

方法: 1.使用new Map() ，2.判断长度：map.size(尺寸，长度)，3.添加元素：map.set( )

4.获取键值:map.get，    5.判断当前对象中不存在该属性：map.has

6.删除当前对象中的属性:map.delete，   7.清空该方法的所有成员:map.clear

## Set数组

概念：新建一个数组，且保证数组中每个值都是唯一的

语法:let a = new Set( )

方法: 1.判断长度：array.size(尺寸，长度)，3.添加元素：array.add( )

  5.判断当前是否中存在该值：array.has( )

6.删除元素:array.delete，   7.清空:array.clear

## Set数组转数组

展开运算符，forEach循环， Array.from(数组名)。

##   Set 判重

  // let array = [2, 22, 2, 233, 3333, 3]

  // let list = new Set(array)

###  Set数组转数组

  // let b = [...list]

  // console.log(b);

  // let c = Array.from(list)

  // console.log(c);

## Set.prototype.keys()：返回键名的遍历器

## Set.prototype.values()：返回键值的遍历器。

## Set.prototype.entries()：返回键值对的遍历器。

## Set.prototype.forEach()：使用回调函数遍历每个成员。

## 以上都是Set自带的方法

let set = new Set([1, 2, 3, 4])

console.log(set);

for (let item of set) {

  console.log(item);

  //返回键值的遍历器

}

for (let item of set.keys()) {

  console.log(item);

  // 返回键名的遍历器

}

for (let item of set.values()) {

  console.log(item);

  //返回键值的遍历器

}

for (let item of set.entries()) {

  console.log(item);

  //返回键值的遍历器

}

set.forEach((key, value) => {

  console.log(key + ':' + value);

})

# day7

## class类

#### 1.es6提供了更接近传统语言的写法，引入了Class(类)的概念，作为对象的模版

#### 2.作用：通过class关键字，可以定义类

#### 3.优点:新的class写法只是让对象原型写法更加清晰，更像面向对象编程的语法而已。

#### 4.class  get，set方法

#### 5.class static定义方法

class  static定义方法

概念：类 ( class ) 通过 **static** 关键字定义静态方法.

特点：不能在类的实例上调用静态方法 , 而应该通过类本身调用 . 这些通常是实用程序方法 , 列如创建或克隆对象的功能 . 

类的继承( 重点! )关键字：extends，关键方法：super ( ) // 父类 . call ( this )

## 数值的扩展

  1.Number.EPSILON 表示最小精度 ，数组的方法Math.abs;取绝对值|a-b| |1-2|=1

   2.十进制 1,2,3 0.2

   3.Number.isFinite 检测一个数值是否有限数 小数和长度是有限的，无线数表示位数是位数是无止尽的

   4.infinite 无穷大

   5.Number.isNaN 判断一个数值是不是NAN

   6.Number.isInteger 判断是不是整数

   7.Number.parseInt Number.parseFloat

   8.Math.trunc 判断一个数，为正数返回1。为负数返回-1。0为0.

## 数组的扩展

数组的扩展

- \1. join()
  - 将数组中所有的元素都装华为字符串在一起，最后返回最后发字符串.

- \2. reverse()
  - 将数组中的元素颠倒顺序，返回到这的数组.

- \3. sort()
  - Array.sort()方法将数组中的元素排序并返回排序后的数组.

- \4. concat()
  - concat() 方法用来合并两个或多个数组

- \5. slice() 可改变原数组
  - 将数组剪切,设定从数组中选择开始的下标(startIndex)和一个结束的下标(endIndex)，切割中间的字段，但是切割的内容包括开始的下标不包括结束的下标.

- \6. push() 后増 可改变原数组
  - 向数组最后添加一个值,并且返回一个数组的新长度,这个会改变原数组.

- \7. pop() 可改变原数组
  - 用于删除并返回最后一个元素.

- \8. unshift() 可改变原数组
  - unshift()在数组的头部添加一个或多个元素，并将已经存在的元素移动到下一个位置。最后返回元素新的长度.

- \9. shift() 可改变原数组
  - shift()删除数组的第一个元素并将他返回，然后把所有随后的元素下移一个位置填补数组头部的空缺.

- \10. filter() 过滤

  - 方法返回数组中满足条件的元素组成的新数组，原数组不变.

  - 方法有三个参数 第一个为当前值，第二个为下标，第三个为当前数组.

- \11. map() 格式化数组
  - 方法将调用的数组的每个元素传递给指定的函数，并返回一个值.

- \12. every()
  - 对数组的每个元素判断是否都满足条件，如果有一个不满足就为false，如果全部满足结果就是true.

- \13. reduce()
  - reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值.

- \14. indexOf() 和 lastIndexOf()

  - indexOf(某元素,startIndex) 从startIndex开始，查找某元素在数组中的位置，若存在，则返回第一个位置的下标,否则返回-1.

  - lastIndexOf(某元素，startIndex) 和indexOf()相同，区别在于从尾部向首部查询.

- \15.  some()
  - 对数组的每一项都运行给定的函数，若存在一项或多项返回 ture,则返回 true.

- \16. forEach()
  - 方法用于调用数组的每一个元素，并将元素传递给回调函数.

## proxy

bable是将es6转化为es5语法是浏览器可以编译出来。

![img](https://api2.mubu.com/v3/document_image/9234b343-9e03-441d-86d5-156889bfbd84-22187535.jpg)

1.概念:pooxy对象于创建一个对象的代理，从而实现基本操作的拦截和自定义(如属性查找，赋值，枚举，函数调用)

2.语法 const p=new proxy(target, handler)

target要使用pooxy包装的目标对象（可以是任何类型的对象，包括原生数组,函数,甚至另一个代理）

handler一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作的时代理p的行为。

应用场景

- v3的reactive的双向绑定原理，跨域

## import和export的使用

import 在您希望按照一定的条件或者按需加载模块的时候，动态 import() 是非常有用的。而静态型的 import 是初始化加载依赖项的最优选择，使用静态 import 更容易从代码静态分析工具和 tree shaking 中受益。模块名只允许单引号和双引号的字符串。 name 导入模块对象整体的别名，在引用导入模块时，它将作为一个命名空间来使用。 export, exportN 被导入模块的导出接口的名称。 alias, aliasN 将引用指定的导入的名称。import {myExport} from '/modules/my-module.js'; 这将 foo 和 bar 插入当前作用域

export有两种不同的导出方式，命名导出*和*默认导出。你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。

# day8-vue

## 介绍与描述

Vue是一套用来动态构建用户界面的渐进式JavaScript 框架。构建用户界面: 把数据通过某种办法变成用户界面
渐进式: Vue可以自底向上逐层的应用,简单应用只需要一个轻量小巧的核心库,复杂应用可以引入各式各样的Vue插件作者: 尤雨溪

## Vue的特点

1.遵循 MVVM 模式
2.编码简洁,体积小，运行效率高.适合移动/PC 端开发
3.它本身只关注 Ul也可以引入其它第三方库开发项目
4，采用组件化模式,提高代码复用率,且代码更好的维护
5.声明式编码让编码人员无需直接操作DOM,提高效率命令式编码声明式编码

## vue3介绍

## 了解vue的mvvm架构

MWM是Model-View-VewModel的简称，是目前非常流行的架构模式。下面是vue的一个比较官方的关于mwm关系图的描述

## 与其它JS 框架的关联

1.借鉴 Angular 的模板和数据绑定技术
2.借鉴 React 的组件化和虚拟 DOM 技术

## Vue3带来了什么

1.性能的提升
打包大小减少41%
初次渲染快55%，更新渲染快133%

## 和市场上和vue并行的三大语言框架为

### React:

它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。

### Angular: 

它两个版本都是强主张的，如果你用它，必须接受以下东西
必须使用它的模块机制
必须使用它的依赖注入
必须使用它的特殊形式定义组件 (这一点每个视图框架都有，难以避免)
所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。
Vue:渐进式框架,主张就是只负责自己的事情,Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,在不同层次可以使用不同的概念

##  Vue 周边库

 vue-cli: vue 脚手架
vue-resource
axios
vue-router: 路由
vuex: 状态管理

element-ui: 基于 vue 的 UI 组件库(PC 端）

## vue的配置文件

##### vue.config.js---

###### 配置webpack文件(包括配置跨域，请求接口，第三方插件配置，rule)

##### package.json--

:scripts:配置启动命令,打包命令,eslint校验代码命令
:browserslist:浏览器适配配置
devDependencies,dependencies:项目node-modules大版本的:限制

^:最大兼容版本
:~:大约在这个版本上下就行

##### package-lockjson

:约束每个node-modules版本下的其他依赖的固定版本

##### babel.config.js: babel插件设置 

##### a.gitignore: 忽略文件

##### Public: 公共入口文件和公共配置配置

#####  src 放置组件和axios配置

:Assets -- 放置图片.img,css,js
" components --放置其他组件所需要的公共组件

router-- 配置路由表,(动态路由,静态路由,权限路由)”

store -- 存放vuex的仓库:Views-- 放置页面的地方
·Home
……
·App.vue 入口的总文件

main.js 实例化vue挂载
Utils-- 所有封装axios,封装token,封装公共方法-----工具类文件|

## vue的语法

##### 3.2 vue的语法

1. 插值语法 {{}}
2. 动态绑定 v-bind(:)
3. 条件渲染: v-if v-else
概念: 控制dom元素的创建和销毁,实现渲染和更新页面
特点: 如果没有v-else的存在,会在dom元素被删除的地方,添加一个标识,在下次进行重新渲染的时候,优先导 dom的循环和查找
4. v-show
1.通过添加或者移除 display: none样式进行控制dom元素的显示与隐藏
5. v-for，Key: 作用为了防止Dom元素的重复渲染,如果以index为key的话,会造成页面的多次渲染和渲染不同。
6. 使用虚拟DOM和Diff算法,尽量复用DOM节点

# day10

## 初识Vue:

1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象;
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法
3.root容器里的代码被称为 [Vue模板] ;
4.Vue实例和容器是一一对应的;
5.真实开发中只有一个Vue实例，并且会配合着组件一起使用;
6.{{xxx}}中的xxx要写is表达式，且xxx可以自动读取到data中的所有属性7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新;
注意区分:js表达式 和 js代码(语句)1.表达式:一个表达式会产生一个值，可以放在任何一个需要值的地方(1)、a(2)。a+b(3)。demo(1)(4).x===y?a':b

 准备好一个容器—创建Vue实例—el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串data:[ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一/

## 2.js代码(语句)

(1)，if()}
(2)，for(){}

## 数据驱动视图

1.对于数据的处理
2.概念: 我们只关注数据,当数据最终变了以后,再去渲染页面3.Css-js，一旦一个数据变化,就会整个重现渲染页面

## Vue模板语法有2大类:

1.插值语法:
功能:用于解析标签体内容。
写法:区xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性
2.指令语法:
功能:用于解析标签 (包括: 标签属性、标签体内容、绑定事件.....)举例: v-bind;href="xxx”或 简写为 :href="xxx”，xxx同样要写is表达式
且可以直接读取到data中的所有属性。
备注: Vue中有很多的指令，且形式都是: v-????，此处我们只是拿v-bind举个例子。

## data与el的2种写法

1.el有2种写法     

1.el在一进页面的时候就会挂载页面，并加载Dom

2.$mount挂载页面，可以控制挂载的实践**/

2.data有2种写法

(1).new Vue时候配置el属性。
(2).先创建Vue实例，随后再通过vm.$mount(#root')指定el的值。

3.一个重要的原则
(1).对象式(2).函数式如何选择:目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。
由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。

el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串

data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象

## 数据绑定

1.双向绑定一般都应用在表单类元素上 (如: input、select等)

2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值.

<!-- 普通写法 -->
单向数据绑定:<input type="text” v-bind:value="name">

双向数据绑定: <input type="text” v-model:value="name">! 

<!-- 简写 -->
单向数据绑定: <input type="text” :value="name">

双向数据绑定: <input type="text” v-model="name">

Vue.config.productionTip = false      阻止 vue 在启动时生成生产提示

## Vue中的MVVM.

MVVM模型
1，M: 模型(Model) : data中的数据
2、V:视图(View) :模板代码
3，VM: 视图模型(ViewModel): Vue实例
观察发现:
1.data中所有的属性，最后都出现在了vm身上2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用

## Object.defineProperty

object.defineProperty
object.defineproperty的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性
Object.defineproperty 参数
Obiect.defineproperty方法需要传递3个参数
Object.defineproperty (obj, prop, desc
需要定义属性的当前对象参数1:obj
参数2:prop当前需要定义的属性名
参数3:desc描述符一般是一个对象
还有最重要的两个属性set和get(即存取器描述:定义属性如何被存取)
当使用了getter或setter方法，不允许使用writable和value这两个属性(如果使用，会直接报错滴)get是获取值的时候的方法，类型为function，获取值的时候会被调用，不设置时为undefined类型为function，设置值的时候会被调用，undefinedset 是设置值的时候的方法，get或set不是必须成对出现，任写其一就可以
enumerable:true，//控制属性是否可以枚举，默认值是falsewritable: true，

//控制属性是否可以被修改，默认值是falseconfigurable:true，

//控制属性是否可以被删除，默认值是false

枚举:可循环的变量和属性

枚举
循环遍历遍历不出来的属性

可循环的变量和属性

## 数据代理

数据代理:通过一个对象代理对另一个对象中属性的操作 (读/写)

## 深入响应式原理

现在是时候深入一下了!Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节

## 双向绑定的原理

当把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。这些getter/setter 对用户来说是有可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。每个组件实例都对应一个watcher 实例，它会在组件渲染的过程中把”接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新道染。

## 事件基本使用

事件的基本使用:
1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名
2.事件的回调需要配置在methods对象中，最终会在vm上;
3.methods中配置的函数，不要用箭头函数! 否则this就不是vm了;

4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象;

5.@click="demo”和 @click="demo($event)” 效果一致，但后者可以传参;

## Vue中的事件修饰符:

1.prevent: 阻止默认事件 (常用) ;
2.stop:阻止事件冒泡 (常用) ;
3.once: 事件只触发一次 (常用) ;
4.capture: 使用事件的捕获模式;
5.self: 只有event.target是当前操作的元素时才触发事件;
6.passive: 事件的默认行为立即执行，无需等待事件回调执行完毕;

冒泡事件的概念:
当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序

捕获
事件处理的另一个阶段被称为“捕获 (capturing)"。它很少被用在实际开发中，但有时是有用的。

DOM 事件标准描述了事件传播的3 个阶段:
1.捕获阶段(Capturing phase)--事件 (从 Window) 向下走近元素。
2.目标阶段(Target phase)-- 事件到达目标元素。
3.冒泡阶段 (Bubbling phase)-事件从元素上开始冒泡。

![image-20221128173153399](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221128173153399.png)

## vue的键盘事件

1.Vue中常用的按键别名:
回车 => enter
删除 => delete (捕获“删除”和“退格“键)
退出 =>esc
空格 =>space
3
换行 => tab (特殊，必须配合keydown去使用)
上=>up下=> down左=> left
右=>right
2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case (短横线命名)
3.系统修饰键 (用法特殊) : ctrl、alt、shift、meta(1).配合keyup使用: 按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。(2).配合keydown使用: 正常触发事件。
4也可以使用keyCode去指定具体的按键 (不推荐)
5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名

# day11

## 计算属性

计算属性:
1.定义:要用的属性不存在，要通过已有属姓计算得来
2.原理: 底层借助了0bjcet.defineproperty方法提供的getter和setter。
3.get函数什么时候执行?
(1).初次读取时会执行一次。(2).当依赖的数据发生改变时会被再次调用。

4.是同步
5.具有缓存性

4.优势: 与methods实现相比，内部有缓存机制 (复用) ，效率更高，调试方便5.备注:
1.计算属性最终会出现在vm上，直接读取使用即可。
2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变

 特点：1.computed具有缓存性

2.computed是同步，不能异步操作

3.数据和属性来源于data数据中，具有多对一的关系 

## watch:

1.定义:监听的属性必须要在data中存在或定义吧。
2.原理: 底层借助了0bjcet.defineproperty方法提供的getter和setter。
3.特点:
1.当被监视的属性变化时，回调函数自动调用，进行相关操作
2.监视的属性必须存在，才能进行监视!!
3.watch是异步的
5.可以配置两个属性 immediate(一进页面立即监听),deep(深度监听)属性

## 深度监视:

(1)Vue中的watch默认不监测对象内部值的改变 (一层)(2)配置deep:true可以监测对象内部值改变 (多层)
(3).一进页面就可以立即监听: immediate:true(4).没有缓存，且是异步的
(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以!
(2)使用watch时根据数据的具体结构，决定是否采用深度监视。
监视属性watch:
1.当被监视的属性变化时，回调函数自动调用，进行相关操作2.监视的属性必须存在，才能进行监视!!
3.监视的两种写法:
(1)new Vue时传入watch配置
(2)通过vm.$watch监视

## 绑定样式:

1，class样式
写法:cLass="xxx” xxx可以是字符串、对象、数组。
字符串写法适用于:类名不确定，要动态获取。
对象写法适用于:要绑定多个样式，个数不确定，名字也不确定。
数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。可以适用于三元表达式
2，style样式
:style="{fontSize: xxx}"其中xxx是动态值;style=“[a,b]“其中a、b是样式对象。

### 绑定class样式

1.字符串写法，适用于: 样式的类名不确定，需要动态指定

2.数组写法，适用于: 要绑定的样式个数不确定、名字也不确定

3.对象写法，适用于;要绑定的样式个数确定、名字也确定，但要动态决定用不用

### 绑定style样式 

1.对象写法， 2.数组写法

##  react、vue中的key有什么作用? (key的内部原理)

1.虚拟DOM中key的作用:
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据[新数据] 生成[新的虚拟DOM]，随后Vue进行[新虚拟DOM] 与[旧虚拟DOM] 的差异比较，比较规则如下:
2.对比规则:
(1)旧虚拟DOM中找到了与新虚拟DOM相同的key:D.若虚拟DOM中内容没变，直接使用之前的真实DOM!2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM.
(2).旧虚拟DOM中未找到与新虚拟DOM相同的key创建新的真实DOM，随后渲染到到页面
3.用index作为key可能会引发的问题:
1。若对数据进行: 逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。
2.如果结构中还包含输入类的DOM:会产生错误DOM更新 => 界面有问题

## 开发中如何选择key?:

1.最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。

2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的

## v-for指令:

1.用于展示列表数据
2.语法: v-for="(item， index) in xxx” :key="yyy“3，可遍历:数组，对象，字符串 (用的很少)、指定次数 (用的很少)

# day12

## 条件渲染

1.v-if
写法:
(1).V-if="表达式"
(2).V-else-if="表达式"
(3).V-else="表达式"
适用于:切换频率较低的场景。
特点: 不展示的DOM元素直接被移除。
注意: v-if可以和:v-else-if、V-else一起使用，但要求结构不能被“打断”
2.V-show
写法: V-show="表达式"适用于:切换频率较高的场景。特点: 不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
3.备注:使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。

## 数据变了，视图没变

数据变了，但是我们的视图没变，vue.Set，this.$set

 Vue.set( target, propertyName/index, value )
参数:
(Object I Array) target0
(string I number] propertyName/index
{any}value
返回值:设置的值。
用法:
向响应式对象中:添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property(比如this.myObject.newProperty = “hi”)
！！！注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象

## 列表渲染

实现一个列表的 模糊 匹配
1:实现列表的展示

1.准备一个数据
2，绘制页面展示效果

2: 模糊匹配，搜索一个关键字，进行查找出全部包含当前关键字的列表信息
3: 防抖;
4:边界情况: 输入空串，空格，特殊的情况时候列表应该怎么展示

总结:可以使用computed
watch
methods

## vue.Set 和this.$set

 Vue.set( target, propertyName/index, value )
参数:
(Object I Array) target
(string I number] propertyName/index
 {any) value
返回值:设置的值。
·用法:
向响应式对象中:添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property(比如this.myObject.newProperty = “hi”)
注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象

## Vue监视数据的原理:

1，vue会监视data中所有层次的数据。
2，如何监测对象中的数据?
通过setter实现监视，且要在new Vue时就传入要监测的数据
(1).对象中后追加的属性，Vue默认不做响应式处理
(2).如需给后添加的属性做响应式，请使用如下API:
Vue.set(target，propertyName/index，value) 或vm.$set(target，propertyName/index， value)
3。如何监测数组中的数据?
通过包裹数组更新元素的方法实现，本质就是做了两件事

(1).调用原生对应的方法对数组进行更新。

(2).重新解析模板，进而更新页面。
4.在Vue修改数组中的某个元素一定要用如下方法:
1.使用这些API;push()、pop()、shift()、unshift()、splice()、sort()、reverse()2.Vue.set() 或 vm.sset()
特别注意: Vue.set()和 vm,Sset() 不能给vm 或 vm的根数据对象 添加属性!!!

## 收集表单数据:

若:<input type="text"/>，则v-model收集的是value值，

用户输入的就是value值.若:<input type="radio”/>，

则v-model收集的是value值，且要给标签配置value值若: <input type="checkbox"/>
1.没有配置input的value属性，那么收集的就是checked (选 or 未勾选，是布尔值)

2.配置input的value属性:

(1)v-model的初始值是非数组，那么收集的就是checked (选 or 未选，是布尔值)

(2)v-model的初始值是数组，那么收集的的就是value组成的数组备注:

 v-model的三个修饰符:lazy: 失去焦点再收集数据number: 输入字符串转为有效的数字trim: 输入首尾空格过滤

## 密码加密

你的登录传给后端的是明文还是密文
1.我是直接明文传输
我通过我们约定的加密方式来进行加密,我将密文传给后端,后端储存到数据库为密文，

输入的是明文----加密(密文)--->后端---->数据库
我加密---> 解密--->后端明文

## 过滤器

时间戳

13位的时间戳包含的是 时分秒
10位的时间戳时分 * 1000

### 过滤器:

定义:对要显示的数据进行特定格式化后再显示 (适用于一些简单逻辑的处理)
语法:
1.注册过滤器: Vue.filter(name,callback) 或 new Vue{filters:IJ}

2.使用过滤器:[ xxx 过滤器名}] 或 vind:属性 =“xxx 过滤器名

### 备注:

1.过滤器也可以接收额外参数、多个过滤器也可以串联
2.落没有改变原本的数据，是产生新的对应的数

Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。

过滤器可以用在两个地方：**双花括号插值和 `v-bind` 表达式** 。

过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：|

## 自带指令

我们学过的指令:
v-bind:单向绑定解析表达式，可简写为 :xxx
v-model : 双向数据绑定
v-for:遍历数组/对象/字符串
v-on: 绑定事件监听，可简写为@
v-if
: 条件渲染 (动态控制节点是否存存在)
v-else:条件渲染 (动态控制节点是否存存在)
V-show:条件渲染 (动态控制节点是否展示)
v-text指令:
1.作用:向其所在的节点中渲染文本内容。
2.与插值语法的区别: v-text会替换掉节点中的内容，{{xx}}则不会。

v-cloak指令 (没有值) :
1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性

2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}的问题。

v-once指令:
1.y-once所在节点在初次动态渲染后，就视为静态内容了。

2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。

v-pre指令:
1.跳过其所在节点的编译过程。
2.可利用它跳过:没有使用指令语法、没有使用插值语法的节点，会加快编滚

## 自定义指令

需求1:定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。
需求2:定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。

## 基本使用

Vue中使用组件的三大步骤:一、定义组件(创建组件)注册组件
使用组件(写组件标签)
一、如何定义一个组件?
使用Vue.extend(options)创建,其中options和new Vue(options)时传入的那个options几乎-样，但也有点区别;
区题如下:1.el不要写，为什么?- 

最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。2.data必须写成函数，为什么?避免组件被复用时，数据存在引用关系。备注: 使用template可以配置组件结构。
二、如何注册组件

1.局部注册: 靠new Vue的时候传入components选项

2.全局注册:靠Vuecomponent('组件名’,组件)

三、编写组件标签:
<school></school>

## 注意点

##### 1.关于组件名:

##### 一个单词组成:

第一种写法(首字母小写): school，第二种写法(首字母大写): School

##### 多个单词组成

第一种写法(kebab-case命名): my-school第二种写法(CamelCase命名): MySchool (需要Vue脚手架支持)

##### 备注:

(1).组件名尽可能更避HTML中已有的元素名称，例如: h2、H2都不行

(2)可以使用name配置项指定组件在开发者工具中呈现的名字。

##### 2.关于组件标签:

第一种写法: <school></school>

第二种写法:<school/>备注:不用使用脚手架时，<school/>会导致后续组件不能渲染

##### 3.一个简写方式:

const school = Vue.extend(options) 可简写为: const school = options

# day13 vue的使用

##   父传子

首先在子组件标签上绑定一个自定义属性，然后在子组件里通过 props 接收这个属性，props 接收有两种方式 数组和对象的形式
父传子的使用场景 封装列表的时候 把数据传到子组件渲染

props 可以接收数组或对象

props: ["name"], *//直接使用数组形式进行简单接收*

1. props: {

2. ​     props: {name: String   //接收的数据名称为name，值类型为字符串型}

3.  props: {
       name: {
         type: String, //指定值类型
         required: true, //是否为必传项
         default: "李四", //默认值，如没有父组件没有传递，则默认name为李四
         //一般required与default不一起使用
       },
     },

4. 在mounted里定义this.$attrs用来收集props未接收的值

   mounted{

   console.log(this.$attrs,‘  ‘)

   }

   ## vue中组件的生命周期，每个生命周期做了什么

   #### 应该在这个生命周期做什么

   1.beforeCreate 在实例初始化之后，数据观测(data observer) 之前被调用。
   2.created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event 事件回调。这里没有$el
   3.beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。
   4.mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
   5.beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。
   6.updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
   7.beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。
   8.destroyed Vue 实例销毁后调用。调用后， Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用

   #### 要掌握每个生命周期内部可以做什么事

   1.created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。
   2.mounted 实例已经挂载完成，可以进行一些DOM操作
   3.beforeUpdate 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
   4.updated 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
   5.destroyed 可以执行一些优化操作,清空定时器，解除绑定事件

   ## 父组件和子组件的生命周期函数的执行顺序

   父组件的创建前
   父组件的创建后
   父组件的挂载前
   子组件的创建前
   子组件的创建后
   子组件的挂载前
   子组件的挂载后
   父组件的挂载后

   ## v-if 是从false-true 经历那些生命周期

   1,v-if 是从false-true 经历那些生命周期
   父组件beforupdate-> 子组件beforeCreate->子组件created->子组件beforeMount->子组件mounted->父组件update2。

   2.v-if 从tue-false 经历那些生命周期
   父:beforeUpdate-> 子组件beforeDestroy -> 子组件destroyed-> 父组件 updated

   3.v-show
   父:beforeUpdate-> 父组件 updated

   ## 混入

   混入(mixin)提供了一种非常灵活的方式，来分发 Vud组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。

   mixin 封装公共的数据和方法，分发数据和功能全局引入:
   Vue.mixin( 混入的js)
   局部引入:
   import 混入的js from路径'  和data同意层级的 mixins: [混入的js
   如果说混入的数据和页面的数据冲突，取的是页面的数据如果说混入的方法和页面的方法冲突，两个都会调用，先调用的混入的方法

   ### 选项合并

   当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先

   ## 本地存储的⽅式有哪些？区别及应⽤场景 **\***

   一般有三种存储的方法
   cookie
   localStorage
   sessionStorage

   cookie 的最大存储是 4kb 可以设置失效时间,到期自动清除 每次会跟随 http 请求一起发送所以不安全，而且操作麻烦，没有方便的 api 方法
   localStorage 是 h5 新增的存储 不能设置过期时间 除非主动删除 否则就一直存在 有方便的 api 存储大小是 5m
   sessionStorage 是临时存储 跟 localStorage 很像 不同的是关闭页面会立即清除

   ## 子传父

   在子组件的标签上绑定一个自定义事件，然后在子组件里通过$emit 调用这个自定义事件，调用这个事件的同时把要传的数据作为参数传到父组件
   子传父的使用场景：在子组件中有删除等方法的时候要在子组件把下标传到父组件操作数据

   ## 组件的自定义事件

1，一种组件间通信的方式，适用于: <strong style="color:red">子组件 ==> 父组件</strong>
2.使用场景:A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件(<span style="color:red">事件的回调在A中</span>)。

3。绑定自定义事件:
1，第一种方式，在父组件中:<Demo @atguigu="test"/><Demo v-on:atguigu="test"/>'
2，第二种方式，在父组件中:

<Demo ref="demo"/>

mounted(){
this.$refs.xxx.$on('atguigu',this.test)

}

3.若想让自定义事件只能触发一次，可以使用once*、修饰符，或$once*、方法。

4.触发自定义事件:this.$emit('atquigu',数据)

5.解绑自定义事件this.$off('atguigu')

6，组件上也可以绑定原生DOM事件，需要使用native、修饰符

7，注意:通过this,$refs,xxx,$on('atguigu',回调)绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题!

#####         全局事件总线 (GLobalEventBus)

1.一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>.

2，安装全局事件总线:

## 为什么data必须是一个函数

vue中data必须是函数是为了保证组件的独立性和可复用性，data是一个函数，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，你实例化几次，就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。

Vue开发的应用一般为单页面应用，一般情况下只有一个Vue实例，所以实例中的数据可以在当前项目中共享，所以Vue实例中的data是一个对象。

Vue组件的出现是为了组件中的视图和数据可以复用（可以简单理解为js中的函数封装），被复用的组件在不同的复用位置可能在操作不同的数据，所以每个组件的data数据必须相互独立，所以组件中的data是一个函数，函数内部返回一个只能让当前组件使用的对象数据。

可以实例中的data可以全局使用(全局意味着可共享，大家都可以用)，所以是对象。

组件的data为data为局部使用(局部意味着不共享，只能自己用)，所以返回对象的函数。

# day14-vue的插槽

插槽 插槽分为匿名插槽、具名插槽、作用域插槽。 子组件中匿名插槽只能有一个；可以有多个具名插槽； 作用域插槽中可以有匿名插槽和具名插槽。 匿名插槽 没有名字 具名插槽 插槽有名字，可以放对应的位置上 子

用name在插槽上起名字 父slot="son",v-slot:son,这两种都可以在父组件使用具名插槽 要注意 v-slot:son这种方式只能在只能这样使用 v-slot:son可以简写为#son 作用域插槽 就是父组件可以获取子组件上的数据使用，正常情况下我们只能通过$emit来获取子组件的数据 子

就跟父传子一样自定义属性 父

{{sonlist}}这里就可以使用sonlist数据

还有一种具名插槽作用域父组件接收数据的方法 子

就跟父传子一样自定义属性 父 v-slot:son="sonlist"这样只能在template中这样用

## 插槽概念：

父组件向子组件传递带数据的标签，当一个组件有不确定的结构时，就需要使用 slot 技术，注意: 插槽内容是在父组件中编译后,再传递给子组件的。

vue中的slot主要分三种 ：**匿名插槽**，**具名插槽，作用域插槽**，

一，匿名插槽：

语法：<slot></slot>

1.没有为插槽指定名称

2.通过slot标签可以添加匿名插槽

3.在使用组件的时候，组件中的内容会填充到所有匿名插槽的位置，所以在封装组件的时候，匿名插槽一般只有一个

4.匿名插槽可以设置默认的内容，如果没有传入内容就使用默认内容，如果传入了，就会进行覆盖。

**二，具名插槽**

**语法：<slot name="名称"></slot>**

1.为slot设置名字的插槽就称为具名插槽

**2.一个封装组件中可以有多个具名插槽**

3.使用：通过template标签指定内容所放置的插槽名称

**4.使用简写：v-slot:名字 或者 #名字**

**定义具名插槽：**

**使用具名插槽：**

**三，作用域插槽**

在封装组件的过程中，可以为预留的 插槽绑定 props 数据(除了name)，这种带有 props 数据的 叫做**“作用域插槽"**

**使用作用域插槽：**在使用包含[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)插槽的组件时，可以使用 **v-slot: 插槽名称** 的形式，接收作用域插槽对外提供的数据

## 路由的理解

## 6.1.1 vue-router 的理解

vue 的一个插件库，专门用来实现 SPA应用

## 对SPA应用的理解

1单页 Web 应用 (single page web application， SPA)。

2. 整个应用只有一个完整的页面

3. 点击页面中的导航链接不会刷新页面，只会做页面的局部更新。

4. 数据需要通过 ajax 请求获取。

   ## SPA 单页面应用的优点：

    ① 良好的交互体验

    内容的改变不需要重新加载整个页面，页面数据的获取通过ajax异步获取，没有页面之间的跳转，不会出现跳转白屏现象。

    ② 良好的前后端分离的工作模式

    前端只需要专注于页面的渲染，更利于前端工程化的发展。

    后端只需要专注于API接口的提供，更易实现API接口的复用。

    ③ 减轻服务器的压力

    服务器只提供数据，不负责页面的合成和逻辑的处理，吞吐能力提高几倍。

   SPA 单页面应用的缺点：
    ① 首屏加载慢

    解决方案：路由懒加载、代码压缩、CDN加速、网络传输压缩

    ② 不利于SEO（搜索引擎优化）

    解决方案：SSR服务器端渲染

### 1.什么是路由?

一个路由就是一组映射关系(key - value)

2. key 为路径,value 可能是 function 或 component
    2.路由分类

  ### 后端路由:

  1)理解:value是function,用于处理客户端提交的请求。
  2) 工作过程: 服务器接收到一个请求时，根据请求路径找到匹配的函数
  来处理请求,返回响应数据。

### 前端路由:

1)理解:value 是 component，用于展示页面内容
当浏览器的路径改变时,对应的组件就会显示。

2) 工作过程:当浏览器的路径改变时,对应的组件就会显示。

## 2.几个注意点

1.路由组件通常存放在 pages 文件夹，一般组件通常存放在 components 文件夹2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。
3每个组件都有自己的 sroute 属性，里面存储着自己的路由信息。
4.整个应用只有一个router，可以通过组件的 srouter 属性获取到。

## 3.多级路由(多级路由)

1.配置路由规则，使用children配置项:

2.跳转(要写完整路径) :
<router-link to="/home/news">News</router-link>

## 4.路由的query参数

1传递参数
<!-- 跳转并携带query参数，to的字符串写法 -->
<router-link :to="/home/message/detal?id=666&tit!=你好”>跳转</router-link>

<!-- 跳转并携带query参数，to的对象写法 -->
<router-link
:to="(
path:'/home/message/detail'
      query:(
               id: 666
               title:'你好'}

}>跳转</router-link>

2.接收参数:
$route.query.id
$route.query.title

## 6路由的params参数

1配置路由，声明接收params参数

2传递参数
<!-- 跳转并携带params参数，to的字符串写法 -->
<router-link;to="/home/message/detail/666/你好>跳转</router-link>
<!--跳转并携带params参数，to的对象写法 -->

<!-- 跳转并携带params参数，to的对象写法 -->
<router-link
:to="(
name:'xiangqing
       params;(
            id:666
            itle:'你好'
}
}"

跳转</router-link>
  特别注意:路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置!

3.接收参数:
$route.params.id
$route.params.title

## query和params的区别

1.query传参地址栏是以?形式拼接的，传参的时候标注了参数和参数值，类似于get请求

2，params传参地址栏是/形式拼接，传参的参数配置实在路由表中已:id这种动态形式进行拼接的，(动态路由传参)，类似于post请求

3。接受参数的方式不同,$route.params和$route.query进行接收

4，params刷新会丢失动态传参,quuery不会

5。params路由跳转对象传参必须以name形式进行跳转

## props传参

//props的第一种写法，值为对象，该对赢中的所有key-value都会以props的形式传给Detail组件，

// props：{a:1,b; hello'}
//props的第二种写法，值为布尔值，若布尔值为真，就会把该路也组件收到的所有parans参数，以props的形式传给Detail

// props:true
//props的第三种写法，值为函数
props($routel(
return {
id:$route,query.id,
title:$route.query.title,
a:1，
b; "hellg",

c:"813寝室“

}   }

## router-link的replace属性

1.作用:控制路由跳转时操作浏览器历史记录的模式

2.浏览器的历史记录有俩种写入方式:分别是push和replace,push是追加历史记录,replace是替换当前记录,路由跳转默认是push

3.如何开启replace模式:<router-link replace...>News</router>

## 编程式路由导航

1.作用:不借助<router-link> 实现路由跳转，让路由跳转更加灵活

2.代码

//srouter的两个API
this.$router.push({name:'xiangqing'params:{
id:xxx,title:xxx}

}）

this.$router.replace({name: 'xiangqingparams:
id:xxx,title:xxx}

}）

this.srouter.forward() //前进

this.$router.back() //后退
this.$router.go() //可前进也可后退

## 缓存路由组件keep-alive

keep-alive 是一个内置组件，作用是缓存不活动的组件不被销毁，下次访问这个组件的时候不会重新加载而是从缓存里拿。
比如说刚填好的表单需要缓存 还有保持滚动条的距离
keep-alive 的黑白名单：可以用 include 和 exclude 规定缓存谁不缓存谁 也可以 使用路由的元信息定义

跟他相关的两个钩子函数的 actived 和 deactived
举例：保持滚动条的距离：
给 router-view 外层套一个 keep-alive

1.作用:让不展示的路由组件保持挂载，不被销毁。

<keep-alive include="News">
<router-view</router-view>
</keep-alive>

1.activated 路由组件被激活时触发
2.deactivated 路由组件失活时触发

## 路由守卫

1.作用:对路由进行权限控制
2.分类:全局守卫、独享守卫、组件内守卫

全局守卫
beforeEach 全局前置守卫
beforeResolve 路由解析之前
afterEach 全局后置守卫

组件级守卫
beforeRouteEnter 路由进入之前
beforeRouteUpdate 路由更新之前
beforeRouteLeave 路由离开之前

单个路由独享的守卫
beforeEnter 路由进入之前

## 路由器的两种工作模式

1.对于一个url来说，什么是hash值?--#及其后面的内容就是ash值。2.hash值不会包含在 HTTP 请求中，即: hash值不会带给服务器。3.hash模式:
1.地址中永远带着#号，不美观。
2.若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
3.兼容性较好。4.history模式:
1.地址干净，美观。
2.兼容性和hash模式相比略差
3.应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。

## vue-router 中有一个 [api](https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020) ，名曰 addRouter

router.addRoutes(routes: Array<RouteConfig>)

addRouter 是 router 实例的一个方法， 可以 动态添加更多的路由规则

这个 api ，可以让你的 router 配置，不用在初始化router实例的时候就写进去

可以在 vue 实例化 以后，动态的添加更多的路由

用途：

你的 router 可以从后台 获取，动态的添加到 router实例中去，

router.options.routes.push(...pages)

router.addRoutes(pages)

vue3删除了addRoutes()，只能addRoute()一条一条进行加入,写addRoutes()是无效的。

# day15-Vux知识点总结

## 一.vuex是什么

Vuex 是一个专为 Vue.js 应用程序开发的态管理模式。它采用集中式存储管理应用的所有组件的状态

## 二、市场上同类型的状态管理工具有

##### 2.1 react

(1). Recoil[1]
(2)MobX(2]
(3)XState(3)
(4)Redux (with hooks)[4]
(5)Context

##### 2.2 vue

(1) vuex

##### 2.3 vue3

(1)pinia

状态管理工具,因为语言发展的历史,react的问世早于vue,所以很多状态管理工具都是为react服务的,vuex是专门为Vue服务的，吸取了redux的单数据管理,去掉了redux的限制,更加适合vue,所以vue选择了,vuex,当然也能用其他的,但是会比vuex复杂很多.。

## 三.核心及使用

1.state 存储数据T组件中使用 this.$store.state.
2.mutations 对象 里面是方法 可以直接操作state中的数据
注意:commit只能传一个参数 如果需要传递多个数据用复杂数据类型比如 数组对象

同步数据

在组件中 this.$store.commit(“模块名/方法名”，参数)
3.getters 是最state中的数据做逻辑处理 类似于计算属性
在组件中 this.$store.getters.方法名
在模块中同理: this.$store.getters.模块名.方法名
4.actions 也是可以操作数据，但是不能直接操作数据 它调用mutations中的方法来操作的数据actions中的方法是异步的，

 mutations中的方法是同步的
在组件中异步修改数据:在组件中通过dispatch调用actions中的方法，在actions中调用mutations中的方法，

在mutations中可以直接操作state中的数据在组件中 this.$store.dispatch(“模块名/方法名”,参数)
5.modules 分模块存储，将state分成模块存储

## 四.在组件中的使用

组件的模块的数据 this.$store.state.user.*"
组件中模块方法 this.$store.commit(方法名,参数)
组件中getters this.Sstore.getters."
组件中actions this.Sstore.dispatch(方法名,参数)

## 五.vuex的运行原理

在组件中通过dispatch调用actions中的方法，在actions方法中commits调用mutations中的方法，在mutations中的方法中可以直接操作state中的数据，只要state中的数据发生改变就会立刻响应到组件的视图上。 (异步)
在组件中通过commit调用mutations中的方法，在mutations中的方法中可以直接操作state中的数据，只要state中的数据发生改变就会立刻响应到组件的视图上。 (同步步)

##### 3.如何进行分模块操作

###### 1，新建modules文件

###### 2，在文件夹中新建每个模块的is文件:例如 user.js

3.写成模块抽离

//state
const state = {

}

//设置actions

const actions = {

}

//设置mutationsconst 

mutations = {

}

export default {
namespaced: true,   隔离，避免重名出现混淆
state,
actions,
mutations}

##### 模块化调用

//this.$store.dispatch( '模块名/actions方法名’，具体值)

//this.$store.commit( '模块名/actions方法名’，具体值)

## 六、vuex中的数据刷新丢失怎么办 (vuex的数据持久化)

1.手动的将数据添加到本地存储中
2.可以使用vuex数据的持久化

##### 下载插件

cnpm install vuex-persistedstate --save

##### 导入插件 store

import persistedState from 'vuex-persistedstate'

##### 挂载插件

默认的使用localStorage
plugins: [persistedState0]
还可以配置成sessionStorage
plugins: [persistedState(fstorage: window.sessionStorage))]

## 七、vuex的映射函数

在组件中 将该组件用到的数据或者方法映射到组件中

##### 1.映射mutations中的方法

在组件中导入 maplplutations
import {mapMutations) from “vuex
在组件中注册
在methods中注册方法
methods:
...mapMutations(['addMes'方法名])}

当成自己的方法就行
this.addMes

##### 2.映射state中的数据

在组件中导入 mapState
import {mapMutations,mapStatel from "vuex
在组件中注册
在computed中注册
computed:
...mapState([属性,message"])}

当成自己的数据
this.message

##### 3.映射getters中的数据

在组件中导入 mapGettersimport {mapMutations,mapState,mapGetters) from “vuex”

在组件中注册
也在computed中注册
当成自己的数据

##### 4.映射actins的写法

在组件中导入 mapActions
import {mapMutations,mapState,mapGetters, mapActions
在methos中注册使用
methods:!
...mapActions(['addMes','xxxxx'])}

当成自己的方法,this.XXX来进行调用

## 八、vuex的运用场景

Vuex是通过全局注入store对象，来实现组件间的状态共享
总之，假如你需要 数据 和 组件 分离，分别处 那么使用 Vuex 是非常合适的相反，如果不需要分离处理，那么不使用 Vuex 也没关系。比如某个数据只跟某组件打交道，是强耦合的。那么这个数据就应该存放在该组件的 data 属性中
如果只是简单的父子组件间传递数据，使用vuex未免有点大材小用，其实只用使用组件间常用的通信方法即可。在大型复杂的项目中(多级组件嵌套》，需要实现一个组件更改某个数据，多个组件自动获取更改后的数据进行业务逻辑处理用vuex比较合适。
涉及到非父子关系的组件，例如兄弟关系、祖孙关系，甚至更远的关系;他们之间如果有数据交互，需要数据和组件的分离，那么应该使用Vuex来实现;如果页面复杂度比较低的话，也可以考虑使用 global-event-bus 来实现;如果只是父子关系的组件数据交互，那么应该考虑使用props进行单向传递;如果涉及到子组件向父组件的数据传递，那么应该考虑使用 emit和on;

## 九映射函数和组件方法的对应关系

mapState----> this.$store.state
mapActions----> this.$store.dispath
mapGetters-->this.$store.getters
mapMutations---> this.$store.commit

##### 1.分模块

mapState(模块名/方法名，值)

##### 2.使用地方

mapState------>computed
mapActions -----> methods
mapGetters ---> computed
mapMutations ---> methods