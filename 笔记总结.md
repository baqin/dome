# 第一天git

## 常见的版本控制工具

主流的版本控制器有如下这些：    

Git（重要） 

SVN（Subversion）（重要）

CVS（Concurrent Versions System）

VSS（Micorosoft Visual SourceSafe）

TFS（Team Foundation Server） 

Visual Studio Online

## 集中版本控制svn

所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改,集中式版本控制，需要联网才行

缺点: 1. 所有的历史代码都存放在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回

优点: 1. 个人本地占用储存空间较小,只需要保存自己修改的内容即可

分布式版本控制 Git

每个人都拥有全部的代码，可以在本地提交，联网之后push到远程仓库就行，只要有一个用户数据没问题，就可以恢复所有数据。

优点：不会因为服务器损坏或者网络问题，造成不能工作的情况！

缺点：增加了本地存储空间的占用

## 启动git

Git Bash ：Unix与Linux风格的命令行，使用最多，推荐最多

Git CMD：Windows风格的命令行

Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

Git区域

Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。

## 常用的Linux命令

平时一定要多使用这些基础的命令！

1）cd : 进入目录。

2）cd . . 回退到上一个目录，直接cd进入默认目录

3）pwd : 显示当前所在的目录路径。

4）ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）

5）touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。

6）rm: 删除一个文件, rm index.js 就会把index.js文件删除。

7）mkdir: 新建一个目录,就是新建一个文件夹。

8）rm -r : 删除一个文件夹, rm -r src 删除src目录

9）mv 移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。

10）reset 重新初始化终端/清屏。

11）clear 清屏。

12）history 查看命令历史。

13）help 帮助。（Mac除外）

14）exit 退出。

15）#表示注释

16) ls: 查看桌面的所有文件

## Git文件四种状态

Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.

Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件

Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !

Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified

## 本地仓库搭建

1、创建全新的仓库，需要用GIT管理的项目的根目录执行：

\# 在当前目录新建一个Git代码库$ git init

2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。

1:windows查看隐藏文件夹 在查看里面勾选

2:mac查看隐藏文件夹 

## 克隆远程仓库

1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！

\# 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]

# 第二天es6

## JS数据类型

1. ***基本数据类型***

number、string、undefined、null、boolean、symbol、bigint

2. ***引用数据类型【对象类型】***

(1) 标准普通对象: object

(2) 标准特殊对象： Array、RegExp、Date、Math、Error...

(3) 非标准特殊对象：Number、String、Boolean...

(4) 可调用对象/执行对象：function

##  JS数据类型转换

#  -------1.Number

Js中的数据类型转换有两种模式，**一种是隐式转换，一种是显示转换**。

<u>**隐式转换**</u>：*浏览器默认去转换，用**Number()***

**①Number**
转换规则：
1.字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN

2.布尔值转换为数字:true–>1,false–>0

3.null–>0,undefined–>NaN

4.Symbol无法转换为数字，会报错:Uncaught TypeError: Cannot convert a Symbol value to a number

 5.BigInt去除"n"

6.把对象转换为数字

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串
- 最后再把字符串基于Number方法转换为数字

 ②**parseInt与parseFloat**

parseInt(val,radix)接受两个参数

- 第一个参数val必须是字符串，如果不是，要先隐式转换为字符串，调用String()
- 第二个参数radix表示进制，如果不写，或者写0，则默认是10进制

#### 2.String

**情景1：String(val)或者val.toString()**
***转换规则：除对象以外，都是直接用字符串包起来**

对象转字符串的转换规则，与对象转数字的规则一样：

- 先调用对象的Symbol.toPrimitive 这个方法
- 如果不存在这个方法，再调用valueOf获取原始值
- 如果获取的值不是原始值，再调用对象的toString把其变为字符串

**情景2：加号+**
***除了数学运算，还可能代表字符串拼接，也会发生字符串转换***

**（1）+有两边，一边是字符串或者某些对象**

console.log(10+'10');	//'1010'

按对象转字符串的转换规则
先new Date()[Symbol.toPrimitive] (‘default’)—>‘Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)’
得到字符串，然后拼接上10—>‘10Wed Aug 03 2022 17:06:42 GMT+0800 (中国标准时间)

- 先[10] [Symbol.toPrimitive]—>undefined
- 然后[10].valueOf()—>[10]

- 再然后[10].toString()—>‘10’

- 最后10+'10’字符串拼接—>‘1010’

#### 3.Boolean

**转换规则：**
***除了“0/NaN/空字符串/null/undefined"五个值是false，其余值都是true***
情景：

- Boolean(val)
- !/!! （！表示取反，！！表示取反再取反，所以！！跟Boolean()是一个意思）
- 条件判断

4.比较时的相互转换规则

**情景1：对象==字符串**
***按对象转字符串规则Symbol.toPrimitive—>valueOf—>toString***
***将对象转成字符串，然后比较***

**情景2：null==undefined**

​	console.log(null==undefined);//true

console.log(null===undefined);//false

**情景3：对象==对象**
***比较的是堆内存地址，地址相同则相等***

**情景4：NaN**

console.log(NaN==NaN);//false
	console.log(NaN===NaN);//false

NaN与任何值都不相等,包括NaN本身

情景5：***除了以上情景，只要两边类型不一致，剩下的都是转换数字，然后再进行比较***
***"==="绝对相等,如果两边类型不同，则直接是false，不会发生数据类型转换。***
例1：console.log([]==false);	//true

# 检测数据类型

### **1.typeof**

***typeof 返回对应类型的字符串***

***总结：typeof 检测基本数据类型比较准，null检测为object不代表它是引用数据类型，null为空是特殊的基本数据类型，引用数据类型都为 object，内置构造函数和函数都为 function***

### 2.instanceof

 ***instanceof 检测类型返回布尔值***

***总结：instanceof 不能检测基本数据类型，判断前者的 proto 是否在后者的原型对象上***

### 3.constructor

***constructor 返回构造函数***

***总结：返回当前值的构造函数，比如向 [] 数组这种，都是通过 new Array() 这样去创建实例的，这个 Array 就是数组的构造函数***

### 4.Object.prototype.toString.call()

***总结：这个方法查的特别的准，可以检查任意类型***

### 5.Object.getPrototypeOf()

// 获取原型，和想要的原型做对比
console.log(Object.getPrototypeOf([]) === Array.prototype); // true
console.log(Object.getPrototypeOf({}) === Object.prototype); // true

### 五种方法的总结**

- ***typeof：这种方法只能检测基本数据类型，null 和对象的不准***

- ***instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型***

- ***constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷***

- ***Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测***

- ***Object.getPrototypeOf()：这种方法获取原型***

  # 作用域及作用域链

  - 所谓作用域通俗点讲就是变量的可作用范围。
  - 一般有三种作用域。全局，函数，块。

## 变量提升及函数提升

##### 什么是变量提升？

变量提升是指将变量声明提升到它所在的作用域的最开始部分

## 什么是函数提升

 创建函数有两种形式，一种是函数声明，另外一种是函数字面量，**只有函数声明才有变量提升**

## 函数提升与变量提升的优先级

**由此可见函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。**

# 运算符

### 1.数学运算符

数学运算符就是常见的**加(+)、减(-)、乘(*)、除(/)、等于(=)、求幂(**)、**自增(++)、自减(--)、加等于(+=)、减等于(-=)**等

### 2.比较运算符

与数学运算中的比较相同**：大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)**等；注意: **全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样**；

### 3.三元表达式

三元表达式可以替代简单的if条件，**表达式为判断条件 ？条件为真 ：条件为假**。

if（3 > 4）{
    console.log("条件为真");
}else {
    console.log("条件为假");
}
// 三元表达式 —— 代码更加简洁清晰
3 > 4 ? console.log("条件为真") : console.log("条件为假")

### 4.短路运算符 && 与 ||

**短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了。**

- &&：从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值；

- || ：为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值；

  // 1.利用||设置默认值，防止代码出错。

  // 假设data需要取出后台返回的context数组,但返回中不包含context，便可以使用||防止找不到对应值而报错。

  const data = res.context || [];
  // 2.利用&&来省略简单if判断,例如：当某一条件为真时执行函数
  if(1 < 2) {
      fn()
  }
  // 可以简写为
  (1 < 2) && fn()

# day3 JS部分

## 数组方法

### isArray() ，判断是不是一个数组

let arr = [1,2];
console.log(arr.isArray()); //true

### push()，向数组***末尾添加***一个或者多个元素，

### ***返回新数组到长度**。**会改变原数组***

let arr = [1,2];
let returnValue = arr.push(3,4,5);
console.log(arr); // [1,2,3,4,5]
console.log(returnValue) // 5

### pop()，删除并返回数组的最后一个元素***，若该数组为空，***

### ***则返回undefined。***原数组改变。***

```
let arr = [1,2,3];
let del = arr.pop();
console.log(arr); // [1,2]
console.log(del); // 3
```

### unshift()*向数组的开头添加一个或多个元素，并返回新的数组长度。原数组改变***

```
let arr = [1,2,3];
let returnValue = arr.unshift(4,5);
console.log(arr); // [4,5,1,2,3]
console.log(returnValue) // 5
```

### shift()**删除并返回数组的第一个元素，若该数组为空，则返回undefined。原数组改变。*

```
let arr = [1,2,3];
let del = arr.shift();
console.log(del);//1
```

### concat()**合并两个或多个数组，生成一个新的数组。原数组不变***

```
let arr = [1,2];
let b = [3,4];
let result = arr.concat(b);
console.log(result) // [1,2,3,4];
```

### reverse()**将数组倒序。原数组改变**

```
let arr = [1,2,3,4];
arr.reverse();
console.log(a); // [4,3,2,1]
```

### sort()对数组元素进行排序，根据字符串UniCode码排序，原数组改变



```
let arr = [1,2,4,3];
// 升序
arr.sort((a,b)=>{
    return a - b;
});
// 降序
arr.sort((a,b)=>{
    return b - a;
})
```

**原理**

1. **当返回值为负数时，那么前面的数在前面，也就是不动**
2. **当返回值为正数时，那么后面的数在前**
3. **为0，不动**

### join()

***将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。***

```
let arr = [1,2,3,4];
let str = arr.join();
let str1 = arr.join('-');
console.log(str); // 1,2,3,4
console.log(str1); // 1-2-3-4
```

### toString()

***此方法将数组转化为字符串***

```
let arr = [1, 2, 3, 4, 5];
let str = arr.toString()
console.log(str)// 1,2,3,4,5
```

### slice()**slice(start,end).从start开始，end之前结束，不到end。不改变原数组**

```
let a = ['项目一','项目二','项目三']
let arr = arr.slice(0,2);
console.log(a); // ["项目一","项目二","项目三"]
console.log(arr); // ["项目一","项目二"]
```

### splice()***splice(start, number, item, item) 从start开始删除number位，***

### ***然后将后面参数插入数组。返回删除元素组成对数组，会改变原数组***

```
let arr = [1,2,3];
let result = arr.slice(1,0,33);
console.log(arr); // [1,2,33,3]
console.log(result); // []
 
```

### indexOf()，**来查找某个元素的位置，如果不存在就返回-1，但是不能判断是否有NaN的元素**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.indexOf('项目二');
console.log(arr); // 1
```

### includes()**判断是否包含某一元素,直接返回true或者false表示是否包含元素，对NaN一样有效。**

```
let arr = ['项目一','项目二','项目三'];
let result = arr.includes('项目一');
console.log(result) // true
```

## 循环方法

### map

- 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
- 不改变原数组
- ***返回值是一个新的数组***

```
let testArr = ['子项0','子项1','子项2'];
let resultArr = testArr.map((item, index) => {
  return `处理·${item}`
});
console.log(resultArr);
// 结果： ["处理·子项0", "处理·子项1", "处理·子项2"]
```

### forEach

- 对数组的每个元素执行一次提供的函数。
- ***总是返回undefined。***
- 不改变原数组

```
let testArr = ['子项0','子项1','子项2'];
testArr.forEach((item, index)=>{
  return `forEach处理${item}`
});
```

### filter

- 对数组的每一项都进行***过滤***，返回符合条件的item组成的数组
- ***不会改变原数组***

```
let filterArr = ['子项0','子项1','子项2'];
let filterResult = filterArr.filter((item, index) => {
  return item === '子项0';
});
console.log(filterArr); // ["子项0", "子项1", "子项2"]
console.log(filterResult);  ["子项0"]
```

### find

- 遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined
- 不会改变数组

```
let findArr = ['子项0','子项1','子项2']
let findResult = findArr.find((item, index) => {
  return item === '子项0';
});
console.log(findResult);
// 结果为: 子项0
```

### findIndex

- ***遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。***
- ***不会改变数组对象。***

```
let findIndexArr = ['子项0','子项1','子项2'];
let findIndexResult = findIndexArr.findIndex((item, index)=>{
  return item === '子项0';
});
console.log(findIndexResult);
// 结果为： 0
```

### every

- 对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。***简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false***

```
let everyArr = [2,3,4];
let everyResult = everyArr.every((item, index)=>{
  return item > 0
});
console.log(everyResult);
// 结果为: true
```

### some

是对数组中每一项运行指定函数，如果该函数对***任一项返回true，则返回true。***

```
let someArr = [2,3,4];
let someResult = someArr.some((item, index)=>{
  return item > 3
});
console.log(someResult);
// 结果为: true
```

### reduce

- 接收一个函数作为累加器（accumulator），数组中的每个值***（从左到右）***开始缩减，最终为一个值。
- 第二个参数作为第一次调用的a的值

```
// reducer
let reduceArr = [0,1,2,3,4]
let reduceResult = reduceArr.reduce((a, b)=>{
  return a + b;
});
console.log(reduceResult);
// 结果: 10
```

### reduceRight

- 和reduce一样是累加器，不过是***从右往左计算***
- 第二个参数作为第一次调用的a的值



## 闭包

答：闭包说的通俗⼀点就是打通了⼀条在函数外部访问函数内部作⽤域的通道。正常情况下函数外部是
访问不到函数内部作⽤域变量的，
表象判断是不是闭包:函数嵌套函数,内部函数被 return 内部函数调⽤外层函数的局部变量
优点：可以隔离作⽤域，不造成全局污染
缺点：由于闭包⻓期驻留内存，则⻓期这样会导致内存泄露
如何解决内存泄露：将暴露全外部的闭包变量置为 null
适⽤场景：封装组件，for 循环和定时器结合使⽤,for 循环和 dom 事件结合.可以在性能优化的过程中,节流
防抖函数的使⽤,导航栏获取下标的使⽤。

## 原型和原型链

#### 原型

通常，我们写一个构造函数都是这样：

注意: 构造函数的首字母一定是大写的

```js
function Person () {
    //...
}

```

我们不在这个构造函数里写任何代码，当我们在浏览器控制台通过`console.dir`打印出这个构造函数时，可以看到它被添加了一个属性`prototype`。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0be9dc80817b4cf79818c0718a5775b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

**构造函数`Person(潘森)`通过`prototype`属性就能访问到它的原型对象，`Person.prototype`就是原型对象** ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3028f79561d7479fad2e5046b93c75c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

当我们需要通过`Person`构造函数创建一个实例时，通常是这么写：

```js
function Person () {
    //...
}
const person = new Person() // 通过new操作符创建一个实例
console.log(person instanceof Person) // true
```

那么`person`实例可以访问`Person`构造函数的原型对象吗? 显然是可以的。

通过new创建的实例上有一个`__proto__`属性（注意⚠前后是两个下划线）可以直接访问原型对象`Person.prototype`。通常，我们将`__proto__`属性称为**隐式原型属性**。

如下图所示 ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cce3b382a18b49748a9ff9e103276b07~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

在原型上定义的属性和方法，在实例上能够继承这些属性和方法。

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype) // true
复制代码
```

此外，如果原型对象`Person.prototype`需要访问它原来的构造函数可以通过`constructor`属性，如下图所示

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf50095d54cd47a6a681a27df9ee501e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

```js
function Person () {
    //...
}
Person.prototype.sayHi = 'Hi'
const person = new Person() // 通过new操作符创建一个实例
console.log(person.sayHi)   // Hi
console.log(person.__proto__ === Person.prototype)   // true
console.log(Person.prototype.constructor === Person) // true
复制代码
```

#### 原型链

当我们需要读取实例上的属性时，JS会先在当前实例上查找是否有该属性，如果没有则通过`__proto__`访问原型去查找是否有该属性，如果有的话就可以直接使用，没有的话，就会再通过`__proto__`去访问原型的原型，因为原型也是一个对象嘛。

`Person.prototype`可以看做是`Object`的实例，这样的话`Person.prototype`通过`__proto__`访问的是`Object`的原型`Object.prototype`，`Object.prototype`也有一个`__proto__`属性，只不过这次不套娃了，它指向的是`null`。

**总结一下：当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**

如下图所示： ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67aed29f79db452c9516589a575ff0ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

上面提到的：`Person.prototype`可以看做是`Object`的实例。

其实我们在JS中创建的对象都是`Object`的实例，他们都会继承`Object`原型对象上的属性和方法，并且 `创建的对象.__proto__ === Object.prototype`

```js
const obj = {}
console.log(obj.__proto__ === Object.prototype) // true
console.log(obj.toString)  // ƒ toString() { [native code] }，toString是继承Object.prototype上的方法

const obj2 = new Object()
console.log(obj2.__proto__ === Object.prototype) // true
console.log(obj2.toString) // ƒ toString() { [native code] }
复制代码
```

既然`Person.prototype`可以看做是Object的实例。那么就可以在Object处引出一个箭头指向`Person.prototype`，表示通过new创建一个实例对象。

最后，再把节点和连线调整一下，最终得到的图如下所示

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba8bb2b3b134c5681eea31bc3c1a8db~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

总结：

什么是原型？

**原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**

什么是prototype?

   **显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。**

什么是 __ proto __ ?

**可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.**

什么是构造函数？

**构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用**

什么是原型链？

**当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**



## this的理解和指向

在 js 中，this 的意思为“这个;当前”，是一个指针型变量，它动态指向当前函数的运行环境。
this 跟函数相关，谁调用这个函数，this 就指向谁，所以 this 跟函数调用时候的环境而不是定义时候的环境相关。
如果没有调用者，就指向全局对象 window。

1. 构造函数
   构造函数里的 this 指向实例化对象
2. 箭头函数
   箭头函数里没有 this，用的 this 是上层所在环境的 this
3. 函数是对象的属性
   this 指向这个对象
4. dom 节点调用一个事件 就指向这个 dom
5. 全局调用 就指向 widnow
6. 计时器里的 this 永远指向 window

## 多维变一维

#####  利用循环每个元素把得到的元素push新数组

  let a=[[4,5],[6,7]]

  let b=[]

  a.forEach(item=>{

​    item.forEach(val=>{

​      b.push(val)

​    })

  })

  console.log(b);

  // 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维数组。

#####  该方法返回一个新数组，对原数据没有影响。

  let data=[1,2,3,[4,5],11,22,[88,99]]

  let res=data.flat(2)

  console.log(res);

# 浅拷贝和深拷贝

浅拷贝 只拷贝一层 如果是复杂数据类型 就复制地址
深拷贝 不管这个对象有多少层 都会拷贝到值而不是地址

常见的浅复制有哪些：展开运算符 concat Object.assign
let arr2 = [...arr];
let arr2 = arr.concat();
let arr2 = Object.assign({}, arr);

深拷贝

JSON.parse(JSON.stringify())

递归 

实现 
先定义一个函数作为递归函数，然后定义一个空对象保存复制之后的结果，用for in 循环这个对象，然后进行判断如果是基本数据类型就直接复制，如果是对象就再执行这个递归函数

# JS 常见的几种继承方式以及优缺点。

- ### 1、原型继承

  实现：

  ```js
  function Super(){ this.a=1 }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){}
  Sub.prototype = new Super()
  
  const test = new Sub()
  console.log( test.say() )// hhh
  ```

  优点：通过原型继承多个引用类型的属性和方法

  缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。如下

  ```js
  function Super(){ this.a=[1,2] }
  function Sub(){}
  Sub.prototype = new Super()
  
  const test1 = new Sub()
  test1.a.push(3)
  console.log(test1.a)// [1,2,3]
  const test2 = new Sub()
  console.log(test2.a)// [1,2,3]
  ```

  ### 2、盗用构造函数

  实现：构造函数模式+call

  ```js
  function Super = function(){ this.a = 1 }
  function Sub = function(){
         Super.call(this)
         this.b = 2
  }
  
  const test = new Sub() 
  ```

  优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染

  缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法

  ### 3、组合继承

  实现：原型继承+盗用构造函数继承

  ```js
  function Super(){ this.a=[1,2] }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){
      Super.call(this)
      this b=2
  }
  Sub.prototype = new Super()
   
  const test1 = new Sub()
  console.log( test1.say() )// hhh
  test1.a.push(3)
  console.log(test1.a)// [1,2,3]
  const test2 = new Sub()
  console.log(test2.a)// [1,2]
  ```

  优点：集合了【原型继承】和【盗用构造函数继承】的优点

  缺点：存在效率问题，Super始终会被调用两次

  ### 4、原型式继承

  实现：

  es5之前

  ```js
  const obj = { a:1 }
  function createObj(o){
      const Fn(){}
      Fn.prototype = o
      return new Fn()
  }
  
  const test = createObj(obj)
  ```

  es5之后

  ```js
  const obj = { a:1 }
  
  const test = Object.create(obj)
  ```

  优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性

  缺点：无法判断实例的构造函数是父类还是子类

  ```js
  const obj = { a:[1,2], b:2 }
  const test1 = Object.create(obj)
  const test2 = Object.create(obj)
  
  test1.a.push(3)
  test1.b=3
  console.log(test1.a, test2.a)// [1,2,3]  [1,2,3]
  console.log(test1.b, test2.b)// 3 2
  ```

  ### 5、寄生式继承

  实现：构造函数模式+工厂模式

  ```js
  function createObj(o){
      let clone = objectCopy(o)
      clone.say=function(){
          console.log(‘hhh’)
      }
      return clone
  }
  
  const obj = { a:1 }
  const test = createObj(obj)
  ```

  优点：根据一个对象克隆创建另一个对象，并增强对象

  缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

  注意：objectCopy不是原生接口，是自定义方法，对入参对象进行复制

  ### 6、寄生式组合继承

  实现：盗用构造函数继承 + 原型式继承

  function Super(){ this.a=[1,2] }
  Super.prototype.say = function(){ console.log(‘hhh’) }
  function Sub(){
      Super.call(this)
      this b=2
  }

  Sub.prototype = Object.create(Super.prototype)
  Sub.prototype.constructor = Sub

  const test = new Sub()

# 同步异步 宏任务 微任务 事件循环***

在 js 中 任务的执行模式有两种 同步（log，for 循环等等） 和 异步（ajax 请求 计时器等）
在异步任务中 又将任务分成了宏任务和微任务，宏任务（计时器，ajax 请求）是浏览器发起的 微任务（promise.then）是 js 自身发起的 在异步任务中 微任务先执行 宏任务后执行

所以任务的执行顺序是：

同步先执行-》异步里的微任务-》异步里的宏任务

promise 本身是一个同步 then 是一个异步的微任务

事件循环 event loop

1. 整个 script 标签是一个宏任务 最开始的时候 会执行整体代码
2. 进行同步任务和异步任务的区分
3. 同步任务直接执行 异步任务进行微任务和宏任务的划分
4. 同步执行完了 执行微任务队列里的微任务 完成后再执行宏任务队列里的宏任务
5. 直到执行完成就进行下一次轮回

# day4 Es6

## 获取DOM获取节点

1. 通过ID获取节点 【返回具体某个节点】
document.getElementById(ID名)
2. 通过标签名获取节点 【返回节点数组，即使只有一个】
    document.getElementsByTagName(标签名)
3. 3.通过标签的name值获取节点 【返回节点数组】
    document.getElementsByName(Name名)
4. 通过class值来获取节点 【返回节点数组】
    document.getElementsByClassName(Class名)
5. 根据选择器返回找到结果集中的第一个
    document.querySelect(“选择器”)
6. 根据选择器返回找到的结果集，是个节点数组
    document.querySelectAll(“选择器”)
7. 获取html的方法(document.documElement)
8. 获取body的方法(document.body)

## 数组和伪数组的区别

- 伪数组的定义

  - 拥有`length`属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)

  - 不具有数组所具有的方法

    所谓真数组，其实可以直接称为：数组。
    当一个对象具有以下特点时，可以称为数组：

    可以按照索引的方式，存储多个数组
    具有length属性，表示数组内数据的长度（个数）
    对象的原型属性__proto__，指向Array类，且可以使用Array的原型对象prototype身上的属性和方法，如：push，pop等。如图1：

常见的伪数组有：函数参数arguments，DOM对象列表(例如document.querySelectorAll('div'))，jQuery中的$('div')等
Array.prototype
伪数组没有Array.prototype，它只是一个对象
数组有Array.prototype，他是对象的同时，也是数组
索引（index）和长度（length）
伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
数组的索引和长度是内置属性定义：

## 将伪数组转成真数组

**方法1:遍历：创建一个空数组，循环遍历伪数组，将遍历出的数据逐一放在空数组中**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [];           // 先创建空数组
for(var i=0;i<ali.length;i++){  // 循环遍历伪数组
    arr[i] = ali[i];    // 取出伪数组的数据，逐个放在真数组中
}

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法2:使用slice方法：利用Array原型对象的slice方法，配合apply，将slice中的this指向伪数组**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.prototype.slice.apply(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法3:利用ES6提供的Array的from方法**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = Array.from(ali);

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法4:利用ES6提供的展开运算符（…）**

var ali = document.getElementsByTagName('li');
console.log(ali);       // [li, li, li, li]
// ali.push("hello");      // TypeError: ali.push is not a function

var arr = [...ali];

arr.push("hello");
console.log(arr);       // [li, li, li, li, "hello"]

**方法5:利用原型的复制：将伪数组的__proto__复制为Array的prototype。但是这种方法有局限性**

## arguments

###### **arguments是一个类似于数组的对象，对应于传递给函数的参数**，他有length属性，arguments[ i ]来访问对象中的元素，但是它不能用[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)的一些方法。例如push、pop、slice等。

arguments虽然不是一个数组，但是它可以转成一个真正的数组。

function argText(a,b,c){
    var actual = arguments.length;   //实际传参个数
    var hope = argText.length   //期望传参个数
    console.log(actual,hope);
    //转换数组：
    var args = [].slice.call(arguments);   //第一种
    var args = Array.prototype.slice.call(arguments);   //第二种
    let args = Array.from(arguments);   //第三种
    let args = [...arguments];   //第四种
    console.log(args)
}
argText(1,2)
//输出: 2 3   

每一个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式" [ ] "引用arguments的元素。

arguments.length为函数实参个数，arguments.callee引用函数自身。

arguments对象是所有函数中可用的局部变量，可以使用arguments对象在函数中引用函数的参数，此参数包含传递给函数的每个参数条目。

arguments.callee：Arguments的callee属性可以调用函数本身，当函数正在执行时才可调用，可以实现方法的递归调用。

function argText(){  

  var e = arguments.callee.toString();    console.log(e); } 

argText(); 

##### **6.arguments.caller：指向调用当前函数的函数**

function argText(){
    if(argText.caller){
        var caller = argText.caller.toString();
        console.log(caller);
    }else{
        console.log("no caller");
    }  
}
function handler(){
    argText();
}
function copyHandler(){
    handler();
}
argText()
//输出: no caller
handler()
//输出: function handler(){argText();}
copyHandler();     
//输出: function handler(){argText();}   

## let

1.变量不能重复声明

2.块级作用域 全局，函数，eval

3.不存在变量提升

4.不影响作用域链

5.当let变成var后，变量会变成全局变量，所以最终的值会变化

## const

特点：

1.声明一个常量，且不可更改，一般常量用大写

2.块级作用域

3.生命的基本数据类型不可更改，复杂数据类型值可以改，

复杂数据类型只修改了堆中间的内容，栈没用变

## 结构赋值

1.数组结构，以下标来进行结构，有序结构，不能单独结构一个值

2.对象结构，以属性名进行结构，可以单独结构任何一个属性

## 模版字符串

原生js的模版字符串用··拼接

## 对象的简化写法

 let name ="赚钱"

  let hope=function(){

​    console.log('赚钱666');

  }

  const PERSION={

​    name, hope,

  }

## 箭头函数

1.可以省略小括号，当形参且只有一个的时候

2.可以省略花括号，当代吗只有一句语句return必须省略，而且语句的执行结果就是函数的返回值

## 函数参数的默认值

1.形参初始化，具有默认值的参数，一般位置要靠后(潜规则)

2.和结构赋值结合

##  rest参数

​    // 1、rest参数(形式为"…变量名"),用于获取函数的多余参数,这样就不需要使用arguments(参数)对象了.

​    // 2、rest参数搭配的变量是一个数组,该变量将多余的参数放入数组中.

​    function add(...a) {

​      let sum = 0;

​      for (var val of a) {

​        sum += val;

​      }

​      return sum

​    }

​    let sum = add(2, 5, 3);//10

​    console.log(sum);

​    // add函数是一个求和函数,利用rest参数,可以向该函数传入任意数目的参数.

​    // 3. rest参数代替arguments变量

​    function sortNumbers() {

​      return Array.prototype.slice.call(arguments).sort();

​    }

​    // rest参数的写法

​    const sortNumbers = (...numbers) => numbers.sort();

​    //4、 res参数中的变量代表一个数组,所以数组特有的方方都可以用于这个变量.下面是一个利用rest参数改写数组push方法的例子

​    function push(array, ...items) {

​      //forEach为每一个

​      items.forEach(function (item) {

​        array.push(item);

​        console.log(item);

​      });

​    }

​    var a = [];

​    push(a, 1, 2, 3);

​    // 5、rest参数之后不能再有其他参数(即只能是最后一个参数), 否则会报错.

​    // 6、函数的length属性, 不包括rest参数

## 扩展运算符

扩展运算符概念: ...扩展运算符将数组转化为,逗号分割的【参数序列】

 1.应用在数组的合并

2.将伪数组转为数组

3.数组的克隆

原生js用逗号的字符串 join(',')

## Symbol

Symbol是es6新增基本数据类型，具有唯一性，不能与其他类型运算

# day5-Promise

## 1.Promise

prominse函数是解决异步编程问题产生,所谓promise,简单说就是一个容器,里面保存着某个未来才会结束的事件从语法上说,promise是一个对象,从它可以获取异步操作的消息，prominse提供统一的API,各种异步操作都可以用同样的方法通过进行处理

## Promise出现的原因：

1.为了解决异步回调地狱问题（第三方回调是不是只执行一次，性能，和多次执行。

2.为了解决信任问题

3.为了解决回调执行顺序问题

4.为了捕捉错误能力

## 特点：

1.有三种状态：pedding(等待中) fulfilled(已成功) rejected(已失败)
一旦状态改变,就不会再变,任何时间都可以得到这个结果 如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果,这与事件(eventloop)完全不同,事件的特点是，如果你错过了它，再去监听,是得不到结果的
promise的返回值无论是不是promise函数,最终都会被封装promise函数进行返回,需要我们用then方法
概念:promise是一个容器,里面存放着异步事件
语法：promise是一个对象,可以获取异步操作的消息
2.状态的变化：
2.1 从等待中到已成功(pedding -> fulfilled)
2.2 从等待中到已失败(pedding -> rejected)
3.一旦状态确定,便不在更改,状态凝固--->resolved 无论什么时候都监听我 我就是这个样子
4.和事件循环的区别
事件循环一旦错过,不会再被监听到
promise状态凝固,永远都可以被监听到
5.promise的回调参数
1.resolve->成功的回调
2.reject-> 失败的回调
 // 实例化promise对象
    let a = new Promise((resolve, reject) => {
        setTimeout(() => {
            // let data='我要休息了'
            // resolve(data)

            let data1 = '错误信息'
            reject(data1)
        })
    })
    a.then(res => {
        console.log(res);
    }).catch(err => {
        console.log(err);
    }) 
    // 1.实例化promise函数
    // 2. 通过 new xmlhttoprequest 实例化连接对象
    // 3.确定请求方式,以及请求的接口路径
    // 4.发送请求
    // 5.绑定事件,处理响应结果
    // 6.prominse函数的调用
    
    /**实例化promise函数*/
    const p = new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest()
        //  创建初始化链接
        xhr.open('GET', 'https://elm.cangdu.org/v1/users/count')
        // 确定请求方法和接口
        xhr.send()
        // 发送
        xhr.onreadystatechange = function () {
            // 处理响应结果
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    // 判断响应码 200-299
                    resolve(xhr.response)
                    //   成功
                } else {
                    reject(xhr.response)
                    // 失败
                }
            }
        }
    })
    p.then(res => {
        console.log(res);
    }, (err) => {
        console.log(err);
    })const fs=require('fs')
const p=new Promise((resolve, reject) => {
    fs.readFile('./为学.md',(err,data)=>{
        if(err) reject(err)
       resolve(data)
    })

 p.then(res=>{

​    console.log(res);

  },(err)=>{

​    console.log(err);

  })

# day6

## Promise方法

#### 1.then 成功的回调

#### 2..catch 

 2.1在链式调试中，catch只捕捉第一个then返回的错误信息

2.2在链式调试中，想要单独捕捉每个then的错误信息，需要每个then后面跟随catch  来进行捕获

#### 3.all   

 语法:Promise.all([p1,p2,p3]).then(res=>{res=>console.log(res)})

特点：1.接受的参数为数组[],2.返回值为一个数组，进行最终的结果

3.必须等待全部参数函数返回成功后，才会执行，不能单独获取任何一个函数的值

#### 4.race 

 语法:Promise.race  ([p1,p2,p3]).then(res=>{res=>console.log(res)})

特点：1.接受的参数为数组[],2.返回值为一个数组，进行最终的结果

3.谁先执行完，返回谁，状态就是谁

#### 5.finally  无论成功或失败都会执行

## 链式调用

1.可以一直.then下去，每个then不会相互阻碍

2.在其中一个then里面return一个值，下一个then里面可以获取到当前的值

## async和await

async快速创建一个异步函数，且基于Promise封装函数。

在函数的开头加上async可成为一个异步函数，在异步函数中返回Promise之前使用的await关键字。

特点:1.await不能单独使用，必须在async定义的函数内部使用

2.获取错误信息需要使用try{}来进行获取，try内部写代码块，catch 获取错误信息，catch捕捉到最后返回的错误信息

## Map对象

概念：为了提供更多数值类型的值，扩宽Object只能使用字符串作为键的延伸

方法: 1.使用new Map() ，2.判断长度：map.size(尺寸，长度)，3.添加元素：map.set( )

4.获取键值:map.get，    5.判断当前对象中不存在该属性：map.has

6.删除当前对象中的属性:map.delete，   7.清空该方法的所有成员:map.clear

## Set数组

概念：新建一个数组，且保证数组中每个值都是唯一的

语法:let a = new Set( )

方法: 1.判断长度：array.size(尺寸，长度)，3.添加元素：array.add( )

  5.判断当前是否中存在该值：array.has( )

6.删除元素:array.delete，   7.清空:array.clear

## Set数组转数组

展开运算符，forEach循环， Array.from(数组名)。

##   Set 判重

  // let array = [2, 22, 2, 233, 3333, 3]

  // let list = new Set(array)

###  Set数组转数组

  // let b = [...list]

  // console.log(b);

  // let c = Array.from(list)

  // console.log(c);

## Set.prototype.keys()：返回键名的遍历器

## Set.prototype.values()：返回键值的遍历器。

## Set.prototype.entries()：返回键值对的遍历器。

## Set.prototype.forEach()：使用回调函数遍历每个成员。

## 以上都是Set自带的方法

let set = new Set([1, 2, 3, 4])

console.log(set);

for (let item of set) {

  console.log(item);

  //返回键值的遍历器

}

for (let item of set.keys()) {

  console.log(item);

  // 返回键名的遍历器

}

for (let item of set.values()) {

  console.log(item);

  //返回键值的遍历器

}

for (let item of set.entries()) {

  console.log(item);

  //返回键值的遍历器

}

set.forEach((key, value) => {

  console.log(key + ':' + value);

})

# day7

## class类

#### 1.es6提供了更接近传统语言的写法，引入了Class(类)的概念，作为对象的模版

#### 2.作用：通过class关键字，可以定义类

#### 3.优点:新的class写法只是让对象原型写法更加清晰，更像面向对象编程的语法而已。

#### 4.class  get，set方法

#### 5.class static定义方法

class  static定义方法

概念：类 ( class ) 通过 **static** 关键字定义静态方法.

特点：不能在类的实例上调用静态方法 , 而应该通过类本身调用 . 这些通常是实用程序方法 , 列如创建或克隆对象的功能 . 

类的继承( 重点! )关键字：extends，关键方法：super ( ) // 父类 . call ( this )

## 数值的扩展

  1.Number.EPSILON 表示最小精度 ，数组的方法Math.abs;取绝对值|a-b| |1-2|=1

   2.十进制 1,2,3 0.2

   3.Number.isFinite 检测一个数值是否有限数 小数和长度是有限的，无线数表示位数是位数是无止尽的

   4.infinite 无穷大

   5.Number.isNaN 判断一个数值是不是NAN

   6.Number.isInteger 判断是不是整数

   7.Number.parseInt Number.parseFloat

   8.Math.trunc 判断一个数，为正数返回1。为负数返回-1。0为0.

## 数组的扩展

数组的扩展

- \1. join()
  - 将数组中所有的元素都装华为字符串在一起，最后返回最后发字符串.

- \2. reverse()
  - 将数组中的元素颠倒顺序，返回到这的数组.

- \3. sort()
  - Array.sort()方法将数组中的元素排序并返回排序后的数组.

- \4. concat()
  - concat() 方法用来合并两个或多个数组

- \5. slice() 可改变原数组
  - 将数组剪切,设定从数组中选择开始的下标(startIndex)和一个结束的下标(endIndex)，切割中间的字段，但是切割的内容包括开始的下标不包括结束的下标.

- \6. push() 后増 可改变原数组
  - 向数组最后添加一个值,并且返回一个数组的新长度,这个会改变原数组.

- \7. pop() 可改变原数组
  - 用于删除并返回最后一个元素.

- \8. unshift() 可改变原数组
  - unshift()在数组的头部添加一个或多个元素，并将已经存在的元素移动到下一个位置。最后返回元素新的长度.

- \9. shift() 可改变原数组
  - shift()删除数组的第一个元素并将他返回，然后把所有随后的元素下移一个位置填补数组头部的空缺.

- \10. filter() 过滤

  - 方法返回数组中满足条件的元素组成的新数组，原数组不变.

  - 方法有三个参数 第一个为当前值，第二个为下标，第三个为当前数组.

- \11. map() 格式化数组
  - 方法将调用的数组的每个元素传递给指定的函数，并返回一个值.

- \12. every()
  - 对数组的每个元素判断是否都满足条件，如果有一个不满足就为false，如果全部满足结果就是true.

- \13. reduce()
  - reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值.

- \14. indexOf() 和 lastIndexOf()

  - indexOf(某元素,startIndex) 从startIndex开始，查找某元素在数组中的位置，若存在，则返回第一个位置的下标,否则返回-1.

  - lastIndexOf(某元素，startIndex) 和indexOf()相同，区别在于从尾部向首部查询.

- \15.  some()
  - 对数组的每一项都运行给定的函数，若存在一项或多项返回 ture,则返回 true.

- \16. forEach()
  - 方法用于调用数组的每一个元素，并将元素传递给回调函数.

## proxy

bable是将es6转化为es5语法是浏览器可以编译出来。

![img](https://api2.mubu.com/v3/document_image/9234b343-9e03-441d-86d5-156889bfbd84-22187535.jpg)

1.概念:pooxy对象于创建一个对象的代理，从而实现基本操作的拦截和自定义(如属性查找，赋值，枚举，函数调用)

2.语法 const p=new proxy(target, handler)

target要使用pooxy包装的目标对象（可以是任何类型的对象，包括原生数组,函数,甚至另一个代理）

handler一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作的时代理p的行为。

应用场景

- v3的reactive的双向绑定原理，跨域

## import和export的使用

import 在您希望按照一定的条件或者按需加载模块的时候，动态 import() 是非常有用的。而静态型的 import 是初始化加载依赖项的最优选择，使用静态 import 更容易从代码静态分析工具和 tree shaking 中受益。模块名只允许单引号和双引号的字符串。 name 导入模块对象整体的别名，在引用导入模块时，它将作为一个命名空间来使用。 export, exportN 被导入模块的导出接口的名称。 alias, aliasN 将引用指定的导入的名称。import {myExport} from '/modules/my-module.js'; 这将 foo 和 bar 插入当前作用域

export有两种不同的导出方式，命名导出*和*默认导出。你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。

# day8-vue

## 介绍与描述

Vue是一套用来动态构建用户界面的渐进式JavaScript 框架。构建用户界面: 把数据通过某种办法变成用户界面
渐进式: Vue可以自底向上逐层的应用,简单应用只需要一个轻量小巧的核心库,复杂应用可以引入各式各样的Vue插件作者: 尤雨溪

## Vue的特点

1.遵循 MVVM 模式
2.编码简洁,体积小，运行效率高.适合移动/PC 端开发
3.它本身只关注 Ul也可以引入其它第三方库开发项目
4，采用组件化模式,提高代码复用率,且代码更好的维护
5.声明式编码让编码人员无需直接操作DOM,提高效率命令式编码声明式编码

## vue3介绍

## 了解vue的mvvm架构

MWM是Model-View-VewModel的简称，是目前非常流行的架构模式。下面是vue的一个比较官方的关于mwm关系图的描述

## 与其它JS 框架的关联

1.借鉴 Angular 的模板和数据绑定技术
2.借鉴 React 的组件化和虚拟 DOM 技术

## Vue3带来了什么

1.性能的提升
打包大小减少41%
初次渲染快55%，更新渲染快133%

## 和市场上和vue并行的三大语言框架为

### React:

它也有一定程度的主张，它的主张主要是函数式编程的理念，比如说，你需要知道什么是副作用，什么是纯函数，如何隔离副作用。它的侵入性看似没有Angular那么强，主要因为它是软性侵入。

### Angular: 

它两个版本都是强主张的，如果你用它，必须接受以下东西
必须使用它的模块机制
必须使用它的依赖注入
必须使用它的特殊形式定义组件 (这一点每个视图框架都有，难以避免)
所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。
Vue:渐进式框架,主张就是只负责自己的事情,Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合,在不同层次可以使用不同的概念

##  Vue 周边库

 vue-cli: vue 脚手架
vue-resource
axios
vue-router: 路由
vuex: 状态管理

element-ui: 基于 vue 的 UI 组件库(PC 端）

## vue的配置文件

##### vue.config.js---

###### 配置webpack文件(包括配置跨域，请求接口，第三方插件配置，rule)

##### package.json--

:scripts:配置启动命令,打包命令,eslint校验代码命令
:browserslist:浏览器适配配置
devDependencies,dependencies:项目node-modules大版本的:限制

^:最大兼容版本
:~:大约在这个版本上下就行

##### package-lockjson

:约束每个node-modules版本下的其他依赖的固定版本

##### babel.config.js: babel插件设置 

##### a.gitignore: 忽略文件

##### Public: 公共入口文件和公共配置配置

#####  src 放置组件和axios配置

:Assets -- 放置图片.img,css,js
" components --放置其他组件所需要的公共组件

router-- 配置路由表,(动态路由,静态路由,权限路由)”

store -- 存放vuex的仓库:Views-- 放置页面的地方
·Home
……
·App.vue 入口的总文件

main.js 实例化vue挂载
Utils-- 所有封装axios,封装token,封装公共方法-----工具类文件|

## vue的语法

##### 3.2 vue的语法

1. 插值语法 {{}}
2. 动态绑定 v-bind(:)
3. 条件渲染: v-if v-else
概念: 控制dom元素的创建和销毁,实现渲染和更新页面
特点: 如果没有v-else的存在,会在dom元素被删除的地方,添加一个标识,在下次进行重新渲染的时候,优先导 dom的循环和查找
4. v-show
1.通过添加或者移除 display: none样式进行控制dom元素的显示与隐藏
5. v-for，Key: 作用为了防止Dom元素的重复渲染,如果以index为key的话,会造成页面的多次渲染和渲染不同。
6. 使用虚拟DOM和Diff算法,尽量复用DOM节点

# day10

## 初识Vue:

1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象;
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法
3.root容器里的代码被称为 [Vue模板] ;
4.Vue实例和容器是一一对应的;
5.真实开发中只有一个Vue实例，并且会配合着组件一起使用;
6.{{xxx}}中的xxx要写is表达式，且xxx可以自动读取到data中的所有属性7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新;
注意区分:js表达式 和 js代码(语句)1.表达式:一个表达式会产生一个值，可以放在任何一个需要值的地方(1)、a(2)。a+b(3)。demo(1)(4).x===y?a':b

 准备好一个容器—创建Vue实例—el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串data:[ //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一/

## 2.js代码(语句)

(1)，if()}
(2)，for(){}

## 数据驱动视图

1.对于数据的处理
2.概念: 我们只关注数据,当数据最终变了以后,再去渲染页面3.Css-js，一旦一个数据变化,就会整个重现渲染页面

## Vue模板语法有2大类:

1.插值语法:
功能:用于解析标签体内容。
写法:区xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性
2.指令语法:
功能:用于解析标签 (包括: 标签属性、标签体内容、绑定事件.....)举例: v-bind;href="xxx”或 简写为 :href="xxx”，xxx同样要写is表达式
且可以直接读取到data中的所有属性。
备注: Vue中有很多的指令，且形式都是: v-????，此处我们只是拿v-bind举个例子。

## data与el的2种写法

1.el有2种写法     

1.el在一进页面的时候就会挂载页面，并加载Dom

2.$mount挂载页面，可以控制挂载的实践**/

2.data有2种写法

(1).new Vue时候配置el属性。
(2).先创建Vue实例，随后再通过vm.$mount(#root')指定el的值。

3.一个重要的原则
(1).对象式(2).函数式如何选择:目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。
由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。

el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串

data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象

## 数据绑定

1.双向绑定一般都应用在表单类元素上 (如: input、select等)

2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值.

<!-- 普通写法 -->
单向数据绑定:<input type="text” v-bind:value="name">

双向数据绑定: <input type="text” v-model:value="name">! 

<!-- 简写 -->
单向数据绑定: <input type="text” :value="name">

双向数据绑定: <input type="text” v-model="name">

Vue.config.productionTip = false      阻止 vue 在启动时生成生产提示

## Vue中的MVVM.

MVVM模型
1，M: 模型(Model) : data中的数据
2、V:视图(View) :模板代码
3，VM: 视图模型(ViewModel): Vue实例
观察发现:
1.data中所有的属性，最后都出现在了vm身上2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用

## Object.defineProperty

object.defineProperty
object.defineproperty的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性
Object.defineproperty 参数
Obiect.defineproperty方法需要传递3个参数
Object.defineproperty (obj, prop, desc
需要定义属性的当前对象参数1:obj
参数2:prop当前需要定义的属性名
参数3:desc描述符一般是一个对象
还有最重要的两个属性set和get(即存取器描述:定义属性如何被存取)
当使用了getter或setter方法，不允许使用writable和value这两个属性(如果使用，会直接报错滴)get是获取值的时候的方法，类型为function，获取值的时候会被调用，不设置时为undefined类型为function，设置值的时候会被调用，undefinedset 是设置值的时候的方法，get或set不是必须成对出现，任写其一就可以
enumerable:true，//控制属性是否可以枚举，默认值是falsewritable: true，

//控制属性是否可以被修改，默认值是falseconfigurable:true，

//控制属性是否可以被删除，默认值是false

枚举:可循环的变量和属性

枚举
循环遍历遍历不出来的属性

可循环的变量和属性

## 数据代理

数据代理:通过一个对象代理对另一个对象中属性的操作 (读/写)

## 深入响应式原理

现在是时候深入一下了!Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节

## 双向绑定的原理

当把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。这些getter/setter 对用户来说是有可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。每个组件实例都对应一个watcher 实例，它会在组件渲染的过程中把”接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新道染。

## 事件基本使用

事件的基本使用:
1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名
2.事件的回调需要配置在methods对象中，最终会在vm上;
3.methods中配置的函数，不要用箭头函数! 否则this就不是vm了;

4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象;

5.@click="demo”和 @click="demo($event)” 效果一致，但后者可以传参;

## Vue中的事件修饰符:

1.prevent: 阻止默认事件 (常用) ;
2.stop:阻止事件冒泡 (常用) ;
3.once: 事件只触发一次 (常用) ;
4.capture: 使用事件的捕获模式;
5.self: 只有event.target是当前操作的元素时才触发事件;
6.passive: 事件的默认行为立即执行，无需等待事件回调执行完毕;

冒泡事件的概念:
当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序

捕获
事件处理的另一个阶段被称为“捕获 (capturing)"。它很少被用在实际开发中，但有时是有用的。

DOM 事件标准描述了事件传播的3 个阶段:
1.捕获阶段(Capturing phase)--事件 (从 Window) 向下走近元素。
2.目标阶段(Target phase)-- 事件到达目标元素。
3.冒泡阶段 (Bubbling phase)-事件从元素上开始冒泡。

![image-20221128173153399](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221128173153399.png)

## vue的键盘事件

1.Vue中常用的按键别名:
回车 => enter
删除 => delete (捕获“删除”和“退格“键)
退出 =>esc
空格 =>space
3
换行 => tab (特殊，必须配合keydown去使用)
上=>up下=> down左=> left
右=>right
2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case (短横线命名)
3.系统修饰键 (用法特殊) : ctrl、alt、shift、meta(1).配合keyup使用: 按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。(2).配合keydown使用: 正常触发事件。
4也可以使用keyCode去指定具体的按键 (不推荐)
5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名

# day11

## 计算属性

计算属性:
1.定义:要用的属性不存在，要通过已有属姓计算得来
2.原理: 底层借助了0bjcet.defineproperty方法提供的getter和setter。
3.get函数什么时候执行?
(1).初次读取时会执行一次。(2).当依赖的数据发生改变时会被再次调用。

4.是同步
5.具有缓存性

4.优势: 与methods实现相比，内部有缓存机制 (复用) ，效率更高，调试方便5.备注:
1.计算属性最终会出现在vm上，直接读取使用即可。
2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变

 特点：1.computed具有缓存性

2.computed是同步，不能异步操作

3.数据和属性来源于data数据中，具有多对一的关系 

## watch:

1.定义:监听的属性必须要在data中存在或定义吧。
2.原理: 底层借助了0bjcet.defineproperty方法提供的getter和setter。
3.特点:
1.当被监视的属性变化时，回调函数自动调用，进行相关操作
2.监视的属性必须存在，才能进行监视!!
3.watch是异步的
5.可以配置两个属性 immediate(一进页面立即监听),deep(深度监听)属性

## 深度监视:

(1)Vue中的watch默认不监测对象内部值的改变 (一层)(2)配置deep:true可以监测对象内部值改变 (多层)
(3).一进页面就可以立即监听: immediate:true(4).没有缓存，且是异步的
(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以!
(2)使用watch时根据数据的具体结构，决定是否采用深度监视。
监视属性watch:
1.当被监视的属性变化时，回调函数自动调用，进行相关操作2.监视的属性必须存在，才能进行监视!!
3.监视的两种写法:
(1)new Vue时传入watch配置
(2)通过vm.$watch监视

## 绑定样式:

1，class样式
写法:cLass="xxx” xxx可以是字符串、对象、数组。
字符串写法适用于:类名不确定，要动态获取。
对象写法适用于:要绑定多个样式，个数不确定，名字也不确定。
数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。可以适用于三元表达式
2，style样式
:style="{fontSize: xxx}"其中xxx是动态值;style=“[a,b]“其中a、b是样式对象。

### 绑定class样式

1.字符串写法，适用于: 样式的类名不确定，需要动态指定

2.数组写法，适用于: 要绑定的样式个数不确定、名字也不确定

3.对象写法，适用于;要绑定的样式个数确定、名字也确定，但要动态决定用不用

### 绑定style样式 

1.对象写法， 2.数组写法

##  react、vue中的key有什么作用? (key的内部原理)

1.虚拟DOM中key的作用:
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据[新数据] 生成[新的虚拟DOM]，随后Vue进行[新虚拟DOM] 与[旧虚拟DOM] 的差异比较，比较规则如下:
2.对比规则:
(1)旧虚拟DOM中找到了与新虚拟DOM相同的key:D.若虚拟DOM中内容没变，直接使用之前的真实DOM!2.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM.
(2).旧虚拟DOM中未找到与新虚拟DOM相同的key创建新的真实DOM，随后渲染到到页面
3.用index作为key可能会引发的问题:
1。若对数据进行: 逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。
2.如果结构中还包含输入类的DOM:会产生错误DOM更新 => 界面有问题

## 开发中如何选择key?:

1.最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。

2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的

## v-for指令:

1.用于展示列表数据
2.语法: v-for="(item， index) in xxx” :key="yyy“3，可遍历:数组，对象，字符串 (用的很少)、指定次数 (用的很少)